{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment SPYSpheres }SPYSpheres}
{\comment Generated byDoxgyen. }
{\creatim \yr2015\mo11\dy19\hr12\min11\sec51}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b ZeroRoboticsGameImpl::Camera} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl::ChallengeInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl::Light} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl::OtherInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl::Picture} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl::PlayerInfo} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs initialization fo the ZR game at the start of a test })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGame} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class of the game object that you will use })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZeroRoboticsGameImpl} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class defines the hidden game implementation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Constants.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A list of constants used in the ZR program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gsp.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRCamera.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRCommRoutines.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZREnergy.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRGame.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains documentation of functions specific to the player side of the game })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRGameInternal.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRGameInternal.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRItems.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ZRLight.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::Camera Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b memoryFilled}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b memorySize}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b cameraOn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b cameraOffTime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b cameraBlocked}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Picture} {\b memory} [{\b CAMERA_MAX_MEMORY}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tookPicture}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b uploadedPictures}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 80 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cameraBlocked\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:cameraBlocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::Camera::cameraBlocked}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file ZRGameInternal.h.}\par
}
{\xe \v cameraOffTime\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:cameraOffTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short {\b ZeroRoboticsGameImpl::Camera::cameraOffTime}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file ZRGameInternal.h.}\par
}
{\xe \v cameraOn\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:cameraOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::Camera::cameraOn}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file ZRGameInternal.h.}\par
}
{\xe \v memory\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Picture} {\b ZeroRoboticsGameImpl::Camera::memory}[{\b CAMERA_MAX_MEMORY}]}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file ZRGameInternal.h.}\par
}
{\xe \v memoryFilled\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:memoryFilled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b ZeroRoboticsGameImpl::Camera::memoryFilled}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file ZRGameInternal.h.}\par
}
{\xe \v memorySize\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:memorySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b ZeroRoboticsGameImpl::Camera::memorySize}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file ZRGameInternal.h.}\par
}
{\xe \v tookPicture\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:tookPicture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::Camera::tookPicture}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file ZRGameInternal.h.}\par
}
{\xe \v uploadedPictures\:ZeroRoboticsGameImpl::Camera}
{\xe \v ZeroRoboticsGameImpl::Camera\:uploadedPictures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::Camera::uploadedPictures}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::ChallengeInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo}
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b currentTime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b random}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b mpLoc} [{\b NUM_ITEMS}][3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlayerInfo} {\b me}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OtherInfo} {\b other}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Light} {\b light}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Camera} {\b camera}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b currentPicID}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b round}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 92 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v camera\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:camera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Camera} {\b ZeroRoboticsGameImpl::ChallengeInfo::camera}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file ZRGameInternal.h.}\par
}
{\xe \v currentPicID\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:currentPicID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::ChallengeInfo::currentPicID}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file ZRGameInternal.h.}\par
}
{\xe \v currentTime\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:currentTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::ChallengeInfo::currentTime}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file ZRGameInternal.h.}\par
}
{\xe \v light\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:light}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Light} {\b ZeroRoboticsGameImpl::ChallengeInfo::light}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 99 of file ZRGameInternal.h.}\par
}
{\xe \v me\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:me}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PlayerInfo} {\b ZeroRoboticsGameImpl::ChallengeInfo::me}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file ZRGameInternal.h.}\par
}
{\xe \v mpLoc\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:mpLoc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::ChallengeInfo::mpLoc}[{\b NUM_ITEMS}][3]}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file ZRGameInternal.h.}\par
}
{\xe \v other\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OtherInfo} {\b ZeroRoboticsGameImpl::ChallengeInfo::other}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file ZRGameInternal.h.}\par
}
{\xe \v random\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:random}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::ChallengeInfo::random}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file ZRGameInternal.h.}\par
}
{\xe \v round\:ZeroRoboticsGameImpl::ChallengeInfo}
{\xe \v ZeroRoboticsGameImpl::ChallengeInfo\:round}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b ZeroRoboticsGameImpl::ChallengeInfo::round}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::Light Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b center}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b greyWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lightWidth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b direction}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nextSwitchTime}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 64 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v center\:ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light\:center}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::Light::center}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file ZRGameInternal.h.}\par
}
{\xe \v direction\:ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light\:direction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::Light::direction}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file ZRGameInternal.h.}\par
}
{\xe \v greyWidth\:ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light\:greyWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::Light::greyWidth}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file ZRGameInternal.h.}\par
}
{\xe \v lightWidth\:ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light\:lightWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::Light::lightWidth}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file ZRGameInternal.h.}\par
}
{\xe \v nextSwitchTime\:ZeroRoboticsGameImpl::Light}
{\xe \v ZeroRoboticsGameImpl::Light\:nextSwitchTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::Light::nextSwitchTime}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::OtherInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo}
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b zrState} [12]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
state_vector {\b sphState}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b mpTime} [{\b NUM_ITEMS}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b score}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b message}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b energy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b mirrorTime}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 53 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v energy\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::OtherInfo::energy}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file ZRGameInternal.h.}\par
}
{\xe \v message\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short {\b ZeroRoboticsGameImpl::OtherInfo::message}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file ZRGameInternal.h.}\par
}
{\xe \v mirrorTime\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:mirrorTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short {\b ZeroRoboticsGameImpl::OtherInfo::mirrorTime}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file ZRGameInternal.h.}\par
}
{\xe \v mpTime\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:mpTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short {\b ZeroRoboticsGameImpl::OtherInfo::mpTime}[{\b NUM_ITEMS}]}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file ZRGameInternal.h.}\par
}
{\xe \v score\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:score}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::OtherInfo::score}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file ZRGameInternal.h.}\par
}
{\xe \v sphState\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:sphState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
state_vector {\b ZeroRoboticsGameImpl::OtherInfo::sphState}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file ZRGameInternal.h.}\par
}
{\xe \v zrState\:ZeroRoboticsGameImpl::OtherInfo}
{\xe \v ZeroRoboticsGameImpl::OtherInfo\:zrState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::OtherInfo::zrState}[12]}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::Picture Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::Picture}
{\xe \v ZeroRoboticsGameImpl::Picture}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b picStored}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b value}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b round}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 73 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v picStored\:ZeroRoboticsGameImpl::Picture}
{\xe \v ZeroRoboticsGameImpl::Picture\:picStored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::Picture::picStored}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file ZRGameInternal.h.}\par
}
{\xe \v round\:ZeroRoboticsGameImpl::Picture}
{\xe \v ZeroRoboticsGameImpl::Picture\:round}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::Picture::round}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file ZRGameInternal.h.}\par
}
{\xe \v value\:ZeroRoboticsGameImpl::Picture}
{\xe \v ZeroRoboticsGameImpl::Picture\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::Picture::value}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl::PlayerInfo Struct Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs initialization fo the ZR game at the start of a test. }}\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b zrState} [12]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
state_vector {\b sphState}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fuelUsed}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b energy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b collisionActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FlareisActive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b userForces} [6]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b initQuat} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b score}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b message}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b acquiringMP} [{\b NUM_ITEMS}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b mpTime} [{\b NUM_ITEMS}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
short {\b mirrorTime}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b mirrors}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lastAttTarget} [4]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lastPosTarget} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs initialization fo the ZR game at the start of a test. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this function to reset all member variables. \par
}{
Definition at line 33 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v acquiringMP\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:acquiringMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::PlayerInfo::acquiringMP}[{\b NUM_ITEMS}]}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file ZRGameInternal.h.}\par
}
{\xe \v collisionActive\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:collisionActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::PlayerInfo::collisionActive}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file ZRGameInternal.h.}\par
}
{\xe \v energy\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::energy}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file ZRGameInternal.h.}\par
}
{\xe \v FlareisActive\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:FlareisActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::PlayerInfo::FlareisActive}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file ZRGameInternal.h.}\par
}
{\xe \v fuelUsed\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:fuelUsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::fuelUsed}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file ZRGameInternal.h.}\par
}
{\xe \v initQuat\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:initQuat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::initQuat}[4]}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file ZRGameInternal.h.}\par
}
{\xe \v lastAttTarget\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:lastAttTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::lastAttTarget}[4]}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file ZRGameInternal.h.}\par
}
{\xe \v lastPosTarget\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:lastPosTarget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::lastPosTarget}[4]}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file ZRGameInternal.h.}\par
}
{\xe \v message\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short {\b ZeroRoboticsGameImpl::PlayerInfo::message}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file ZRGameInternal.h.}\par
}
{\xe \v mirrors\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:mirrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::PlayerInfo::mirrors}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file ZRGameInternal.h.}\par
}
{\xe \v mirrorTime\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:mirrorTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
short {\b ZeroRoboticsGameImpl::PlayerInfo::mirrorTime}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file ZRGameInternal.h.}\par
}
{\xe \v mpTime\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:mpTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short {\b ZeroRoboticsGameImpl::PlayerInfo::mpTime}[{\b NUM_ITEMS}]}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file ZRGameInternal.h.}\par
}
{\xe \v score\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:score}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::score}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file ZRGameInternal.h.}\par
}
{\xe \v sphState\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:sphState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
state_vector {\b ZeroRoboticsGameImpl::PlayerInfo::sphState}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file ZRGameInternal.h.}\par
}
{\xe \v userForces\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:userForces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::userForces}[6]}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file ZRGameInternal.h.}\par
}
{\xe \v zrState\:ZeroRoboticsGameImpl::PlayerInfo}
{\xe \v ZeroRoboticsGameImpl::PlayerInfo\:zrState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::PlayerInfo::zrState}[12]}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGame Class Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class of the game object that you will use. }}\par
{
{\f2 #include <ZRGame.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getFuelRemaining} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendMessage} (unsigned char inputMsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b receiveMessage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFacingOther} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the camera is pointed towards the other satellite. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b takePic} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to take a picture in the current position. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getPicPoints} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines how many points a picture would give if taken immediately. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMemoryFilled} () const \par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns how many memory slots are currently in use. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMemorySize} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of memory slots available to the satellite. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b uploadPics} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to upload pictures taken to Earth. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCameraOn} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure the camera is on. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getEnergy} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells how much energy the player has. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getOtherEnergy} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells how much energy the opponent has, at a cost of 0 energy. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b posInLight} (float pos[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in the light zone. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b posInDark} (float pos[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in the dark zone. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b posInGrey} (float pos[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in a grey zone. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posInArea} (float pos[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 1 if the given coordinate is in the light, -1 if in the dark, and 0 otherwise. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getLightInterfacePosition} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the center of the grey zone at the tail end of the light zone is. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getDarkGreyBoundary} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the boundary between the dark zone and the grey zone is. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getLightGreyBoundary} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the boundary between the light zone and the grey zone is. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getLightSwitchTime} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines how long until the light and dark zones next switch (2D/3D). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumItem} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of total items in play, whether they have been picked up yet or not. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b useMirror} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses a held mirror item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMirrorTimeRemaining} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the amount of time left on your current mirror. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getNumMirrorsHeld} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of mirrors currently held and available for use. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getItemLoc} (float pos[], int itemID)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the location of a given item into the given array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b hasItem} (int itemID)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells who has a given item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getItemType} (int itemID)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns what the item does. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getScore} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the player's current score. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b getOtherScore} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the opponent's current score. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getCurrentTime} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the time. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGame} ({\b ZeroRoboticsGameImpl} &impl, ZeroRoboticsAPIImpl &{\b apiImpl})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the game. The provided references should be singleton instances. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ZeroRoboticsGame} & {\b instance} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGameImpl} & {\b pimpl}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REQUIRED: reference to the game implementation, do not delete! }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ZeroRoboticsAPIImpl & {\b apiImpl}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class of the game object that you will use. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains publicly available member functions. \par
}{
Definition at line 34 of file ZRGame.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ZeroRoboticsGame\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:ZeroRoboticsGame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGame::ZeroRoboticsGame} ({\b ZeroRoboticsGameImpl} & {\i impl}, ZeroRoboticsAPIImpl & {\i apiImpl})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for the game. The provided references should be singleton instances. }}\par
{
Definition at line 51 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                                                           : pimpl(impl), apiImpl(apiImpl)\par
\{\par
  impl.game = this;\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCurrentTime\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getCurrentTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getCurrentTime} ()}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the time. }}\par
{
Definition at line 460 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.currentTime;\par
\}\par
}
}
{\xe \v getDarkGreyBoundary\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getDarkGreyBoundary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getDarkGreyBoundary} ()}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the boundary between the dark zone and the grey zone is. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The y-coordinate of the plane between the dark zone and the grey zone. \par
}}{
Definition at line 122 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.light.center - pimpl.challInfo.light.direction * LIGHT_GREY_WIDTH * 0.5;\par
\}\par
}
}
{\xe \v getEnergy\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getEnergy} ()}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells how much energy the player has. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Amount of energy the player satellite currently has. \par
}}{
Definition at line 46 of file ZREnergy.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                   \{\par
  return pimpl.challInfo.me.energy;\par
\}\par
}
}
{\xe \v getFuelRemaining\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getFuelRemaining}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getFuelRemaining} ()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells the player how much fuel remains.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid float indicating how many seconds of fuel remain. \par
}}{
Definition at line 451 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  ZeroRoboticsGameImpl::ChallengeInfo& challInfo = pimpl.challInfo;\par
  float total = PROP_ALLOWED_SECONDS-challInfo.me.fuelUsed;\par
  total = MIN_FUEL(total, 0.0f); //~Prevents fuel from being less than 0.0f\par
  total = MAX_FUEL(total, PROP_ALLOWED_SECONDS); //~Prevents fuel from being greater than MAX fuel in tank\par
  return total;\par
\}\par
}
}
{\xe \v getItemLoc\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getItemLoc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGame::getItemLoc} (float {\i pos}[], int {\i itemID})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the location of a given item into the given array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{A pointer to an array of size 3 which will be overwritten by the item location. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i itemID} \cell }{The integer identifier of a given item. \cell }
{\row }
}
}{
Definition at line 101 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                          \{\par
  memcpy(pos, pimpl.challInfo.mpLoc[itemID], 3 * sizeof(float));\par
\}\par
}
}
{\xe \v getItemType\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getItemType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getItemType} (int {\i itemID})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns what the item does. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Possible Item Types:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ITEM_TYPE_ADD_SCORE\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ITEM_TYPE_ADD_ENERGY\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ITEM_TYPE_MIRROR\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i itemID} \cell }{The integer identifier of a given item. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The corresponding item type to the given identifier. \par
}}{
Definition at line 105 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                             \{\par
  if (itemID < NUM_ITEMS) return ITEM_TYPES[itemID];\par
  return -1; // Error\par
\}\par
}
}
{\xe \v getLightGreyBoundary\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getLightGreyBoundary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getLightGreyBoundary} ()}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the boundary between the light zone and the grey zone is. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The y-coordinate of the plane between the light zone and the grey zone. \par
}}{
Definition at line 118 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.light.center + pimpl.challInfo.light.direction * LIGHT_GREY_WIDTH * 0.5;\par
\}\par
}
}
{\xe \v getLightInterfacePosition\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getLightInterfacePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getLightInterfacePosition} ()}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines where the center of the grey zone at the tail end of the light zone is. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The tail end is at the lower Y-coordinate of the light zone, disregarding any portion that has wrapped around.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The y-coordinate of the light interface plane. \par
}}{
Definition at line 114 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.light.center;\par
\}\par
}
}
{\xe \v getLightSwitchTime\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getLightSwitchTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getLightSwitchTime} ()}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines how long until the light and dark zones next switch (2D/3D). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Number of seconds until the light switches. \par
}}{
Definition at line 111 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                            \{\par
  return pimpl.challInfo.light.nextSwitchTime - pimpl.challInfo.currentTime;\par
\}\par
}
}
{\xe \v getMemoryFilled\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getMemoryFilled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getMemoryFilled} () const}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns how many memory slots are currently in use. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The number of memory slots used. \par
}}{
Definition at line 43 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.camera.memoryFilled;\par
\}\par
}
}
{\xe \v getMemorySize\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getMemorySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getMemorySize} ()}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of memory slots available to the satellite. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This includes both used and unused slots.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Number of memory slots available. \par
}}{
Definition at line 48 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.camera.memorySize;\par
\}\par
}
}
{\xe \v getMirrorTimeRemaining\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getMirrorTimeRemaining}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getMirrorTimeRemaining} ()}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the amount of time left on your current mirror. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid remaining time with a mirror up, zero if no mirror is up. \par
}}{
Definition at line 120 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  int mirrorEnd = pimpl.challInfo.me.mirrorTime + ITEM_MIRROR_DURATION;\par
  int timeLeft = mirrorEnd - pimpl.challInfo.currentTime;\par
  if(timeLeft > 0 && pimpl.challInfo.me.mirrorTime != 0)\par
    return timeLeft;\par
  return 0;\par
\}\par
}
}
{\xe \v getNumItem\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getNumItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getNumItem} ()}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of total items in play, whether they have been picked up yet or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Number of total items. \par
}}{
Definition at line 97 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                  \{\par
  return NUM_ITEMS;\par
\}\par
}
}
{\xe \v getNumMirrorsHeld\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getNumMirrorsHeld}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::getNumMirrorsHeld} ()}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of mirrors currently held and available for use. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid number of mirrors held by the player. \par
}}{
Definition at line 129 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.me.mirrors;\par
\}\par
}
}
{\xe \v getOtherEnergy\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getOtherEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getOtherEnergy} ()}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells how much energy the opponent has, at a cost of 0 energy. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Amount of energy the opponent satellite currently has. \par
}}{
Definition at line 49 of file ZREnergy.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                       \{\par
  bool energyUsed = pimpl.tryToUseEnergy(ENERGY_COST_GET_OTHER_ENERGY);\par
  if(energyUsed)\par
    return pimpl.challInfo.other.energy;\par
  return 0;\par
\}\par
}
}
{\xe \v getOtherScore\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getOtherScore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getOtherScore} ()}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the opponent's current score. }}\par
{
Definition at line 443 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.other.score;\par
\}\par
}
}
{\xe \v getPicPoints\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getPicPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getPicPoints} ()}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines how many points a picture would give if taken immediately. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Does not actually take a picture. Costs 0.1 energy.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The amount of points that the picture is worth. \par
}}{
Definition at line 61 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if(!pimpl.challInfo.camera.cameraOn) \{\par
        return 0;\par
    \}\par
\par
  if (!pimpl.tryToUseEnergy(ENERGY_COST_GET_PIC_POINTS)) \{\par
    return 0;\par
  \}\par
\par
  return pimpl.picPointsImpl();\par
\}\par
}
}
{\xe \v getScore\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:getScore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::getScore} ()}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the player's current score. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Player satellite score. \par
}}{
Definition at line 438 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.me.score;\par
\}\par
}
}
{\xe \v hasItem\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:hasItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::hasItem} (int {\i itemID})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells who has a given item. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i itemID} \cell }{The integer identifier of a given item. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 if you have picked up the specified item, 1 if the other player has, or -1 if no one has. \par
}}{
Definition at line 88 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                        \{\par
  int a = -1;\par
  if (pimpl.challInfo.me.mpTime[itemID] != MP_EMPTY)\par
    a = 0;\par
  if (pimpl.challInfo.other.mpTime[itemID] != MP_EMPTY)\par
    a = 1;\par
  return a;\par
\}\par
}
}
{\xe \v instance\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:instance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGame} & {\b ZeroRoboticsGame::instance} (){\f2  [static]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieves the singleton instance of the game API. Users are not allowed to construct a game instance, so the API must be retrieved through this interface.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid singleton of the game API \par
}}{
Definition at line 43 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                              \{\par
  static ZeroRoboticsGame gameInstance(ZeroRoboticsGameImpl::instance(), ZeroRoboticsAPIImpl::instance());\par
  return gameInstance;\par
\}\par
}
}
{\xe \v isCameraOn\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:isCameraOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::isCameraOn} ()}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes sure the camera is on. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the camera is usable, false if not. \par
}}{
Definition at line 74 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return pimpl.challInfo.camera.cameraOn;\par
\}\par
}
}
{\xe \v isFacingOther\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:isFacingOther}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::isFacingOther} ()}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the camera is pointed towards the other satellite. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the camera is facing the other satellite, false otherwise. \par
}}{
Definition at line 192 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                     \{\par
  return pimpl.isFacingOther();\par
\}\par
}
}
{\xe \v posInArea\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:posInArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGame::posInArea} (float {\i pos}[])}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 1 if the given coordinate is in the light, -1 if in the dark, and 0 otherwise. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{An array of three floats in (x, y, z) order. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 1 if the given coordinate is in the light, -1 if in the dark, and 0 else. \par
}}{
Definition at line 127 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                \{\par
  #ifdef ALLIANCE\par
  return pimpl.sphereInMovingArea(position);\par
  #else\par
  return pimpl.sphereInSwitchingArea(position);\par
  #endif  \par
\}\par
}
}
{\xe \v posInDark\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:posInDark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::posInDark} (float {\i pos}[])}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in the dark zone. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{An array of three floats in (x, y, z) order. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the coordinate is in dark, false else. \par
}}{
Definition at line 139 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                 \{\par
  return pimpl.sphereInDark(position);\par
\}\par
}
}
{\xe \v posInGrey\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:posInGrey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::posInGrey} (float {\i pos}[])}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in a grey zone. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{An array of three floats in (x, y, z) order. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the coordinate is in grey, false else. \par
}}{
Definition at line 143 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                 \{\par
  return !pimpl.sphereInDark(position) && !pimpl.sphereInLight(position);\par
\}\par
}
}
{\xe \v posInLight\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:posInLight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::posInLight} (float {\i pos}[])}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the given coordinate is in the light zone. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pos} \cell }{An array of three floats in (x, y, z) order. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the coordinate is in light, false else. \par
}}{
Definition at line 135 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                   \{\par
  return pimpl.sphereInLight(position);\par
\}\par
}
}
{\xe \v receiveMessage\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:receiveMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char {\b ZeroRoboticsGame::receiveMessage} ()}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Recieve value from 0-255 from other satellite.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An unsigned char containing a value from 0-255. \par
}}{
Definition at line 470 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return (unsigned char)pimpl.challInfo.other.message;\par
\}\par
}
}
{\xe \v sendMessage\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:sendMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGame::sendMessage} (unsigned char {\i inputMsg})}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a value from 0-255 to the other satellite.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i inputMsg} \cell }{Unsigned Char to be sent to other satellite. \cell }
{\row }
}
}{
Definition at line 465 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  pimpl.challInfo.me.message = (short)inputMsg;\par
\}\par
}
}
{\xe \v takePic\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:takePic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::takePic} ()}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to take a picture in the current position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The camera will be disabled for 3 seconds after an attempt, whether successful or not. Costs 1.0 energy.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The amount of points that the picture taken is worth. \par
}}{
Definition at line 53 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if(!pimpl.challInfo.camera.cameraOn) \{\par
    return 0;\par
  \}\par
  return pimpl.takePicImpl();\par
\}\par
}
}
{\xe \v uploadPics\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:uploadPics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGame::uploadPics} (void )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to upload pictures taken to Earth. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Will fail if not facing Earth (3D/Alliance). Disables camera for three seconds upon sucessful upload. Costs 1.0 energy.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The total score over the course of the game so far. \par
}}{
Definition at line 202 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                   \{\par
  float totalScore = 0.0;\par
  if(!pimpl.tryToUseEnergy(ENERGY_COST_UPLOAD_PICTURES)) return 0.0;\par
\par
  GAME_TRACE(("[%d] trying to upload... ", apiImpl.api->getTime()));\par
\par
  // Need to check that the SPHERE isn't going too fast to upload.\par
  float speed = mathVecMagnitude(&pimpl.challInfo.me.zrState[9],3);\par
  if (speed>UPLOAD_ANG_VEL)\par
  \{\par
    GAME_TRACE(("Rotating too fast, Upload Failed. Speed=%2.4f",speed));\par
    return 0.0;\par
  \}\par
\par
// Need to check if the SPHERE is pointing towards earth before running the code to upload pictures.\par
#ifndef ZR2D\par
  if (!pimpl.isFacingEarth())\par
  \{\par
  return totalScore;\par
  GAME_TRACE(("Not Facing Earth, Upload Failed. "));\par
  \}\par
#endif\par
  pimpl.challInfo.camera.uploadedPictures = true;\par
  pimpl.disableCamera();            // For only three seconds.\par
  for (unsigned int i = 0; i < pimpl.challInfo.camera.memoryFilled; i++)\par
    \{\par
  if (pimpl.challInfo.camera.memory[i].picStored == true)\par
  \{\par
    pimpl.challInfo.camera.memory[i].picStored = false;\par
          pimpl.challInfo.me.score += pimpl.challInfo.camera.memory[i].value;\par
    totalScore  += pimpl.challInfo.camera.memory[i].value;\par
          GAME_TRACE(("uploaded picture for %4.2f points | ", pimpl.challInfo.camera.memory[i].value));\par
       \}\par
    \}\par
  pimpl.challInfo.camera.memoryFilled = 0;\par
\par
\par
  return totalScore;\par
\}\par
}
}
{\xe \v useMirror\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:useMirror}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGame::useMirror} ()}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses a held mirror item. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the item existed and was used, false otherwise. \par
}}{
Definition at line 110 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if(pimpl.challInfo.me.mirrors > 0)\{\par
    pimpl.challInfo.me.mirrors -= 1;\par
    pimpl.challInfo.me.mirrorTime = pimpl.challInfo.currentTime;\par
    return true;\par
  \}\par
  return false;\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v apiImpl\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:apiImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ZeroRoboticsAPIImpl& {\b ZeroRoboticsGame::apiImpl}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 292 of file ZRGame.h.}\par
}
{\xe \v pimpl\:ZeroRoboticsGame}
{\xe \v ZeroRoboticsGame\:pimpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl}& {\b ZeroRoboticsGame::pimpl}{\f2  [private]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REQUIRED: reference to the game implementation, do not delete! }}\par
{
Definition at line 291 of file ZRGame.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGame.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRCamera.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZREnergy.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRItems.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRLight.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZeroRoboticsGameImpl Class Reference\par \pard\plain 
{\tc\tcl2 \v ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class defines the hidden game implementation. }}\par
{
{\f2 #include <ZRGameInternal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Camera}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ChallengeInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Light}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b OtherInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Picture}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b PlayerInfo}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs initialization fo the ZR game at the start of a test. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b update} (float forceTorqueOut[6])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs an update of the game rules and calls the user function loop(). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b updateGameModeManeuver} (float forceTorqueOut[6])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b updateGameOverManeuver} (float forceTorqueOut[6], unsigned char &finalScore)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateStates} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b enforceBoundaries} (float forceTorque[6])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Called on every gspControl control cycle. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b limitDirection} (state_vector ctrlState, float ctrlControl[6], unsigned int idx, float dir)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Limits the direction in which the programmed SPHERE can travel and slows down the velocity if it travels in the direction of the limit. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendDebug} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Called on every gspControl control cycle, It should be used to send debug and telemetry information to the ground. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendInit} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for Corona SPHERES: sends POI & Solar Flare info to Sat 2 at start of game }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processRXData} (default_rfm_packet packet)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Processes SPHERES telemetry data }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b breakTie} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b modify2DForceTorque} (float forceTorque[6])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resolveCollision} (float zrState[12], float forceTorqueOut[6])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b dist3d} (float *pos1, float *pos2) const \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b photoBomb} (float zrState[12], float poiLoc[3])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b randomizeStartingLocs} (int itemID, int coord)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b itemPickUp} (int objectNum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initCamera} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disableCamera} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b activateCamera} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b memoryLoss} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFacingPos} (float position[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFacingOther} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFacingEarth} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b takePicImpl} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the score value of the picture, or 0 if taking the picture failed. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b picPointsImpl} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetPicsTaken} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sphereInSwitchingArea} (float position[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sphereInMovingArea} (float position[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sphereInLight} (float position[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sphereInDark} (float position[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b switchLightDirection} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initLight} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateLight} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initEnergy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateEnergy} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b tryToUseEnergy} (float amount)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGameImpl} (ZeroRoboticsAPIImpl &{\b apiImpl})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for binding an API implementation. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ZeroRoboticsGameImpl} & {\b instance} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieves singleton instance of the game implementation. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChallengeInfo} {\b challInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ZeroRoboticsAPIImpl & {\b apiImpl}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reference to ZR API instance. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGame} * {\b game}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Back pointer to the game instance. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const state_vector {\b initState}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Initial state where the satellite is initialized. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class defines the hidden game implementation. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Any internal utility functions or game ru//les functsions hould be put here. You may also override any of the standard GSP functions by implementing them here. The functions {\b init()}, {\b update()}, and {\b sendDebug()} are required. \par
}{
Definition at line 25 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ZeroRoboticsGameImpl\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:ZeroRoboticsGameImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl::ZeroRoboticsGameImpl} (ZeroRoboticsAPIImpl & {\i apiImpl})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for binding an API implementation. }}\par
{
Definition at line 56 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid : apiImpl(apiImpl) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v activateCamera\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:activateCamera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::activateCamera} ()}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  challInfo.camera.cameraOn = true;\par
  GAME_TRACE(("[%d] camera ON | ", apiImpl.api->getTime()));\par
\}\par
}
}
{\xe \v breakTie\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:breakTie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::breakTie} ()}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v disableCamera\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:disableCamera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::disableCamera} ()}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  challInfo.camera.cameraOffTime = apiImpl.api->getTime();\par
  challInfo.camera.cameraOn = false;\par
  GAME_TRACE(("[%d] camera OFF | ", apiImpl.api->getTime()));\par
\}\par
}
}
{\xe \v dist3d\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:dist3d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::dist3d} (float * {\i pos1}, float * {\i pos2}) const}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 428 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  float tmpVec[3];\par
  mathVecSubtract(tmpVec,static_cast<float*>(pos1),static_cast<float*>(pos2),3);\par
  return mathVecMagnitude(tmpVec,3);\par
\}\par
}
}
{\xe \v enforceBoundaries\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:enforceBoundaries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::enforceBoundaries} (float {\i forceTorque}[6])}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Called on every gspControl control cycle. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It should be used to send debug and telemetry information to the ground. \par
}{
Definition at line 383 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  state_vector sphState;\par
  apiImpl.api->getMySphState(sphState);\par
  bool retValue = false;\par
\par
  //Run velocity controller to stop motion out of volume\par
  //Zero out any controls that are leading the user out of the volume\par
  for (int i=0; i<3; i++)\par
  \{\par
    if (sphState[POS_X+i] > limits[i])\par
    \{\par
      limitDirection(sphState, forceTorqueOut, i, 1.0f);\par
      retValue = true;\par
    \}\par
    else if (sphState[POS_X+i] < -limits[i])\par
    \{\par
      limitDirection(sphState, forceTorqueOut, i, -1.0f);\par
      retValue = true;\par
    \}\par
  \}\par
  return retValue;\par
\}\par
}
}
{\xe \v init\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::init} (void )}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  /*  Game Initialization setup.\par
  * Then set the locations of the memory packs.\par
  */\par
\par
  apiImpl.gameTime = GAME_TIME;\par
  memset(&challInfo,0,sizeof(ChallengeInfo));   // general clear of challInfo to 0 = false = empty\par
\par
  // update the state data on challInfo\par
  updateStates();\par
  challInfo.me.score = START_SCORE;\par
\par
  // Lights, Camera, Action!\par
  initLight();\par
  initCamera();\par
  initEnergy();\par
\par
  initItems();\par
\par
\par
\par
  // send information to ground and sat2 at the end of init\par
  sendDebug();\par
\par
\}\par
}
}
{\xe \v initCamera\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:initCamera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::initCamera} ()}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  challInfo.camera.memoryFilled = 0;\par
  challInfo.camera.memorySize = CAMERA_DEFAULT_MEMORY;\par
  challInfo.camera.cameraOn = true;\par
  challInfo.camera.cameraBlocked = false;\par
\}\par
}
}
{\xe \v initEnergy\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:initEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::initEnergy} ()}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file ZREnergy.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                       \{\par
  challInfo.me.energy = STARTING_ENERGY;\par
\}\par
}
}
{\xe \v initItems\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:initItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::initItems} ()}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                     \{\par
  #ifndef ALLIANCE\par
  for(int i = 0; i<NUM_ITEMS; i++)\par
  \{\par
    challInfo.me.mpTime[i]    = MP_EMPTY;\par
    challInfo.other.mpTime[i] = MP_EMPTY;\par
    for(int j = 0; j<3; j++)\par
      challInfo.mpLoc[i][j] = ITEM_LOC[i][j];\par
  \}\par
  #else\par
  float r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[0][0] = r * 0.25f + 0.05;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[0][1] = r * 0.3f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[0][2] = r * 0.5f;\par
\par
  challInfo.mpLoc[1][0] = -challInfo.mpLoc[0][0];\par
  challInfo.mpLoc[1][1] = challInfo.mpLoc[0][1];\par
  challInfo.mpLoc[1][2] = challInfo.mpLoc[0][2];\par
\par
  challInfo.mpLoc[2][0] = 0.0f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[2][1] = r * 0.3f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[2][2] = r * 0.5f;\par
\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[3][0] = r * 0.25f + 0.05f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[3][1] = r * 0.2f + 0.4;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[3][2] = r - 0.5f;\par
\par
  challInfo.mpLoc[4][0] = -challInfo.mpLoc[3][0];\par
  challInfo.mpLoc[4][1] = challInfo.mpLoc[3][1];\par
  challInfo.mpLoc[4][2] = challInfo.mpLoc[3][2];\par
\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[5][0] = r * 0.25f + 0.05f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[5][1] = r * 0.2f + 0.4;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[5][2] = r - 0.5f;\par
\par
  challInfo.mpLoc[6][0] = -challInfo.mpLoc[5][0];\par
  challInfo.mpLoc[6][1] = challInfo.mpLoc[5][1];\par
  challInfo.mpLoc[6][2] = challInfo.mpLoc[5][2];\par
\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[7][0] = r * 0.2f + 0.3;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[7][1] = r * 0.3f;\par
  r = (float) (rand() % 10000) / (10000.0);\par
  challInfo.mpLoc[7][2] = r * 0.2f - 0.5f;\par
\par
  challInfo.mpLoc[8][0] = -challInfo.mpLoc[7][0];\par
  challInfo.mpLoc[8][1] = challInfo.mpLoc[7][1];\par
  challInfo.mpLoc[8][2] = challInfo.mpLoc[7][2];\par
\par
  for(int i = 0; i<NUM_ITEMS; i++)\par
  \{\par
    challInfo.me.mpTime[i]    = MP_EMPTY;\par
    challInfo.other.mpTime[i] = MP_EMPTY;\par
    //printf("Item %d at (%f,%f,%f)\\n", i, challInfo.mpLoc[i][0], challInfo.mpLoc[i][1], challInfo.mpLoc[i][2]);\par
  \}\par
  #endif\par
  challInfo.me.mirrors = STARTING_MIRRORS;\par
  challInfo.me.mirrorTime = 0;\par
  challInfo.other.mirrorTime = 0;\par
\par
\}\par
}
}
{\xe \v initLight\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:initLight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::initLight} ()}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                      \{\par
  challInfo.light.direction = 1;\par
  #ifdef ALLIANCE\par
\par
    #if (SPHERE_ID == SPHERE1)\par
      //float s = ((float) rand()) / ((float) RAND_MAX);\par
      challInfo.light.center = -0.2;  //s * 1.6 - 0.8;\par
      challInfo.light.nextSwitchTime = -1; // shouldn't be utilized\par
    #endif\par
\par
    challInfo.light.greyWidth = LIGHT_GREY_WIDTH*.5;\par
    challInfo.light.lightWidth = LIGHT_WIDTH;\par
  #else\par
    #if (SPHERE_ID == SPHERE1)\par
      challInfo.light.center = 0.0;\par
      challInfo.light.nextSwitchTime = ((unsigned int) rand()) % 30 + 30;\par
    #endif\par
\par
    challInfo.light.greyWidth = LIGHT_GREY_WIDTH;\par
  #endif\par
\}\par
}
}
{\xe \v instance\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:instance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl} & {\b ZeroRoboticsGameImpl::instance} (){\f2  [static]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieves singleton instance of the game implementation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The game implementation singleton \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton instance of the game implementation \par
}{
Definition at line 38 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                      \{\par
  ///Singleton instance of the game implementation\par
  static ZeroRoboticsGameImpl gameImplInstance(ZeroRoboticsAPIImpl::instance());\par
  return gameImplInstance;\par
\}\par
}
}
{\xe \v isFacingEarth\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:isFacingEarth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::isFacingEarth} ()}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 196 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                          \{\par
  float earth [3];\par
  memcpy(earth, EARTH, 3 * sizeof(float));\par
  return mathVecInner(&challInfo.me.zrState[ZR_ATT_X], earth, 3) > MAX_FACING_ANGLE;\par
\}\par
}
}
{\xe \v isFacingOther\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:isFacingOther}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::isFacingOther} ()}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 186 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                          \{\par
  bool facing = isFacingPos(challInfo.other.zrState);\par
  //GAME_TRACE(("isFacingOther: facing = %d| ", facing));\par
  return facing;\par
\}\par
}
}
{\xe \v isFacingPos\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:isFacingPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::isFacingPos} (float {\i position}[])}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 174 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                        \{\par
  float relativePos[3];\par
  mathVecSubtract(relativePos, position, challInfo.me.zrState, 3);\par
  mathVecNormalize(relativePos, 3);\par
  //Check if generally pointing at the other satellite (dot product) and\par
  //if within a small margin of error (to account for noise)\par
  //after bugfix, increased allowed error to 0.25f from 0.0575f\par
  // MAX_FACING_ANGLE = 0.968912f is cosf(0.25f)\par
  bool facing = mathVecInner(&challInfo.me.zrState[ZR_ATT_X], relativePos, 3) > MAX_FACING_ANGLE;\par
  return facing;\par
\}\par
}
}
{\xe \v itemPickUp\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:itemPickUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::itemPickUp} (int {\i objectNum})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file ZRItems.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  /*\par
  This function will replicate that of the 2013 game's item PickUp function with\par
  a few minor changes.\par
  */\par
\par
  state_vector sphState;\par
  apiImpl.api->getMySphState(sphState);\par
  float dist,speed;\par
  dist = dist3d(sphState, challInfo.mpLoc[mpNum]);\par
  speed = mathVecMagnitude(&sphState[3],3);           // VEL_X needs to be changed. - 3\par
  if (speed<MP_SPEED && dist<=MP_RADIUS)\par
  \{\par
    if (challInfo.me.mpTime[mpNum] == MP_EMPTY && challInfo.other.mpTime[mpNum] == MP_EMPTY)\{\par
      challInfo.me.mpTime[mpNum] = apiImpl.api->getTime();\par
      switch (ITEM_TYPES[mpNum])\{\par
        case ITEM_TYPE_ADD_SCORE : \{challInfo.me.score = challInfo.me.score + ITEM_SCORE;\par
                  GAME_TRACE(("Score item picked up"));\par
                  break;\par
              \}\par
        /*case ITEM_TYPE_ADD_MEMORY : \{challInfo.camera.memorySize = challInfo.camera.memorySize + ITEM_MEMORY_SIZE;\par
                  GAME_TRACE(("memory item picked up"));\par
                  break;\} */\par
        case ITEM_TYPE_ADD_ENERGY: \{challInfo.me.energy = challInfo.me.energy + ITEM_ENERGY;\par
                  if (challInfo.me.energy > MAX_ENERGY) \{\par
                    challInfo.me.energy = MAX_ENERGY;\par
                  \}\par
                  GAME_TRACE(("energy item picked up"));\par
                  break;\}\par
        case ITEM_TYPE_MIRROR:\{  challInfo.me.mirrors += 1;\par
                GAME_TRACE(("Mirror picked up"));\par
                break;\par
              \}\par
      \}\par
      GAME_TRACE(("score: %f, energy: %f, memorySize: %d", challInfo.me.score, challInfo.me.energy, challInfo.camera.memorySize));\par
\par
\par
\par
\par
    \}\par
/*\par
    if (!challInfo.me.acquiringMP[mpNum] && mathVecMagnitude(&sphState[RATE_X],3) <= MAX_START_MP)\par
    \{\par
      challInfo.me.acquiringMP[mpNum] = true;\par
      memcpy(challInfo.me.initQuat,&sphState[QUAT_1],4*sizeof(float));\par
    \}\par
    if (challInfo.me.acquiringMP[mpNum] && fabsf(mathVecInner(challInfo.me.initQuat,&sphState[QUAT_1],4)) < MP_ROTATION_ANGLE)\par
    \{\par
      challInfo.me.acquiringMP[mpNum] = false;\par
      //Check for item pickup: item not already picked up by either player,\par
      //and item conditions have been met\par
      if (challInfo.me.mpTime[mpNum] == MP_EMPTY && challInfo.other.mpTime[mpNum] == MP_EMPTY)\par
      \{\par
        //Record pickup time with game time\par
        challInfo.me.mpTime[mpNum] = apiImpl.api->getTime();\par
        //challInfo.camera.memorySize++;\par
        challInfo.me.score = challInfo.me.score + ITEM_SCORE;\par
        GAME_TRACE(("[%d] picked up item %d | ", apiImpl.api->getTime(), mpNum));\par
      \}\par
    \}\par
*/\par
  \}\par
  else\par
  \{\par
    challInfo.me.acquiringMP[mpNum] = false;\par
  \}\par
  return false;\par
\par
  // return true;\par
\}\par
}
}
{\xe \v limitDirection\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:limitDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::limitDirection} (state_vector {\i ctrlState}, float {\i ctrlControl}[6], unsigned int {\i idx}, float {\i dir})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Limits the direction in which the programmed SPHERE can travel and slows down the velocity if it travels in the direction of the limit. }}\par
{
Definition at line 407 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  // if command is to move out further in same direction as limit\par
  if (ctrlControl[idx]*dir >= 0.0f)\par
  \{\par
    ctrlControl[idx] = -1.0f * OOBgain * ctrlState[VEL_X+idx];  // slow down to get 0 velocity (ignore position)\par
  \}\par
\}\par
}
}
{\xe \v memoryLoss\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:memoryLoss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::memoryLoss} ()}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  memset(challInfo.camera.memory,0,CAMERA_MAX_MEMORY*sizeof(Picture));  // erase memory\par
  challInfo.camera.memoryFilled = 0;                                    // reset counter\par
  GAME_TRACE(("[%d] memory CLEARED | ", apiImpl.api->getTime()));\par
\}\par
}
}
{\xe \v modify2DForceTorque\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:modify2DForceTorque}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::modify2DForceTorque} (float {\i forceTorque}[6])}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  state_vector myState, targetState;\par
  apiImpl.api->getMySphState(myState);\par
  memcpy(targetState, myState, sizeof(state_vector));   \par
  \par
  targetState[POS_Z] = 0.0f;\par
  targetState[VEL_Z] = 0.0f;\par
  targetState[10] = 0.0f;\par
  targetState[11] = 0.0f;\par
  targetState[12] = 0.0f;\par
\par
  float q_sw[4], q_tw[4];\par
  float axis[3] = \{0.0f, 0.0f, -1.0f\};\par
  swingTwistDecomposition(&targetState[QUAT_1], q_sw, q_tw, axis);\par
  quatToPositive(q_tw);\par
  memcpy(&targetState[QUAT_1], q_tw, 4*sizeof(float));\par
  \par
  state_vector error;\par
  findStateError(error, myState, targetState);\par
\par
  float newForces[6] = \{0\};\par
  \par
  ctrlPositionPD(KPpositionPD, KDpositionPD, error, newForces);\par
  ctrlAttitudeNLPIDwie(KPattitudePID, KIattitudePID, KDattitudePID, \par
             KPattitudePID, KIattitudePID, KDattitudePID, \par
             KPattitudePID, KIattitudePID, KDattitudePID, \par
             1.0f, error, newForces);\par
  forceTorque[FORCE_Z] = newForces[FORCE_Z];\par
  forceTorque[TORQUE_X] = newForces[TORQUE_X];\par
  forceTorque[TORQUE_Y] = newForces[TORQUE_Y];\par
\}\par
}
}
{\xe \v photoBomb\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:photoBomb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::photoBomb} (float {\i zrState}[12], float {\i poiLoc}[3])}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v picPointsImpl\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:picPointsImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::picPointsImpl} ()}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  // check if other in light or grey zone, camera is on, the spheres are facing\par
  bool isCameraOn = challInfo.camera.cameraOn;\par
  bool isFacingOtherResult = isFacingOther();\par
  bool isOppNotInDarkZone = !sphereInDark(challInfo.other.zrState);\par
  bool myMirror = challInfo.me.mirrorTime != 0 && challInfo.me.mirrorTime + ITEM_MIRROR_DURATION > challInfo.currentTime;\par
  bool otherMirror = challInfo.other.mirrorTime != 0 && challInfo.other.mirrorTime + ITEM_MIRROR_DURATION > challInfo.currentTime;\par
  float picturePointValue = 0;\par
  if (isCameraOn && isFacingOtherResult && isOppNotInDarkZone && !myMirror)\par
  \{\par
    float bet[3], distance;\par
    mathVecSubtract(bet, challInfo.me.zrState, challInfo.other.zrState, 3);\par
    distance = mathVecMagnitude(bet, 3);\par
\par
    if (distance < PHOTO_MIN_DISTANCE) \{\par
      GAME_TRACE(("Not a good shot: too close to the other satellite | "));\par
      return 0.0;\par
    \}\par
    picturePointValue = 2.0 + 0.1/(distance - PHOTO_MIN_DISTANCE + 0.1);\par
    if(otherMirror)\{\par
      #ifdef ZR2D\par
      picturePointValue = 0;\par
      #else\par
      picturePointValue = -1*picturePointValue;\par
      #endif\par
      GAME_TRACE(("Not a good shot: Opposing mirror active %f|", picturePointValue));\par
    \}\par
\par
  \}\par
  else if(!isCameraOn)\{\par
    GAME_TRACE(("Not a good shot: camera off |"));\par
  \}\par
  else if(myMirror)\{\par
    GAME_TRACE(("Not a good shot: my mirror's in the way |"));\par
  \}\par
  else if(!isFacingOtherResult) \{\par
        GAME_TRACE(("Not a good shot: not facing the other satellite | "));\par
    \}\par
  else if(!isOppNotInDarkZone)\{\par
    GAME_TRACE(("Not a good shot: opponent in dark zone |"));\par
  \}\par
  return picturePointValue;\par
\}\par
}
}
{\xe \v processRXData\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:processRXData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::processRXData} (default_rfm_packet {\i packet})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Processes SPHERES telemetry data }}\par
{
Definition at line 11 of file ZRCommRoutines.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if (packet[PKT_CM] == COMM_CMD_DBG_SHORT_SIGNED)\par
  \{\par
    dbg_short_packet DebugVecShort;\par
    memcpy(DebugVecShort, &packet[PKT_DATA], sizeof(dbg_short_packet));\par
    if (ctrlManeuverNumGet() > 2)\par
    \{\par
      for (int i = 0; i < NUM_ITEMS; i++)\{\par
        challInfo.other.mpTime[i] = DebugVecShort[i+1];\par
\par
      \}\par
      // copy general data during game run\par
      challInfo.other.mirrorTime = DebugVecShort[14];\par
      challInfo.other.message = DebugVecShort[15];\par
    \}\par
    else \{\par
      // initialization data for items\par
      if (DebugVecShort[0] == 0)\{\par
        #if (SPHERE_ID == SPHERE1)\par
          // get data from SPHERE2\par
          for (int i = 0; i < NUM_ITEMS - 5; i++)\{\par
                  challInfo.mpLoc[i + 5][0] = DebugVecShort[3*i + 1] / 10000.0f;\par
                  challInfo.mpLoc[i + 5][1] = DebugVecShort[3*i + 2] / 10000.0f;\par
                  challInfo.mpLoc[i + 5][2] = DebugVecShort[3*i + 3] / 10000.0f;\par
          \}\par
        #else\par
          // get data from SPHERE1\par
          for (int i = 0; i < 5; i++)\{\par
                  challInfo.mpLoc[i][0] = DebugVecShort[3*i + 1] / 10000.0f;\par
                  challInfo.mpLoc[i][1] = DebugVecShort[3*i + 2] / 10000.0f;\par
                  challInfo.mpLoc[i][2] = DebugVecShort[3*i + 3] / 10000.0f;\par
          \}\par
\par
        #endif\par
      \}\par
    \}\par
  \}\par
  else if (packet[PKT_CM] == COMM_CMD_DBG_SHORT_UNSIGNED)\par
  \{\par
    dbg_ushort_packet DebugVecUShort;\par
    memcpy(DebugVecUShort, &packet[PKT_DATA], sizeof(dbg_ushort_packet));\par
      int cmn = ctrlManeuverNumGet();\par
      // printf("cmn %d\\n",cmn);\par
      // recieve initialization packet (control maneuver 1)\par
      if (cmn < 3)\{\par
        #if (SPHERE_ID == SPHERE2)\par
          // printf("Init DebugVecShort Received by Sphere 2: %d (should be 0), %d\\n", DebugVecShort[0], cmn);\par
          // make sure its one of our initialization packets, all other debugVecShort[0] are time * 10, so they are larger than 0\par
          if (DebugVecUShort[0] == 0)\par
          \{\par
            challInfo.light.nextSwitchTime = (int) DebugVecUShort[1];\par
          \}\par
\par
        #endif\par
      \}\par
\par
    //challInfo.other.mpTime[0] = DebugVecUShort[1];\par
    //challInfo.other.mpTime[1] = DebugVecUShort[2];\par
  \}\par
  else if (packet[PKT_CM] == COMM_CMD_DBG_FLOAT)\par
  \{\par
    dbg_float_packet DebugVecFloat;\par
    memcpy(DebugVecFloat, &packet[PKT_DATA], sizeof(dbg_float_packet));\par
    int cmn = ctrlManeuverNumGet();\par
    if (cmn < 3) \{\par
        #if (SPHERE_ID == SPHERE2)\par
          //printf("Init DebugVecFloat Received by Sphere 2: %f (should be -1), %d\\n", DebugVecFloat[0], cmn);\par
          // make sure its one of our initialization packets. tstep should be nonnegative, I think.\par
        if (DebugVecFloat[0] == 0.0f)\par
        \{\par
          challInfo.light.center = DebugVecFloat[1];\par
          challInfo.light.direction = DebugVecFloat[2];\par
\par
          return;\par
        \}\par
        #endif\par
    \}\par
    challInfo.other.score = DebugVecFloat[1];\par
    challInfo.other.energy = DebugVecFloat[3];\par
  \}\par
\}\par
}
}
{\xe \v randomizeStartingLocs\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:randomizeStartingLocs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::randomizeStartingLocs} (int {\i itemID}, int {\i coord})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resetPicsTaken\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:resetPicsTaken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::resetPicsTaken} ()}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resolveCollision\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:resolveCollision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::resolveCollision} (float {\i zrState}[12], float {\i forceTorqueOut}[6])}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 417 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  for (int i=0; i<3; i++)\par
  \{\par
    if (zrState[i] > 0)\par
      limitDirection(zrState, forceTorqueOut, i, -1.0f);\par
    else if (zrState[i] < 0)\par
      limitDirection(zrState, forceTorqueOut, i, 1.0f);\par
  \}\par
\}\par
}
}
{\xe \v sendDebug\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sendDebug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::sendDebug} (void )}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Called on every gspControl control cycle, It should be used to send debug and telemetry information to the ground. }}\par
{
Definition at line 94 of file ZRCommRoutines.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  dbg_short_packet  DebugVecShort; // short[16]\par
  dbg_ushort_packet DebugVecUShort; // ushort[16]\par
  dbg_float_packet  DebugVecFloat; // float[8]\par
  unsigned int tstep;\par
\par
  // send debug after estimator convergence\par
  if (ctrlManeuverNumGet() < 3)\par
  \{\par
    sendInit();\par
  \}\par
  if (ctrlManeuverNumGet() > 1)\par
  \{\par
    // normal game packages\par
    tstep = apiImpl.api->getTime();\par
\par
    if (!tstep) return;   // only send starting with time 1, since time 0 can cause problems with initialization\par
\par
    // initialize all packets to 0\par
    memset(DebugVecShort,  0, sizeof(dbg_short_packet));\par
    memset(DebugVecUShort, 0, sizeof(dbg_ushort_packet));\par
    memset(DebugVecFloat,  0, sizeof(dbg_float_packet));\par
\par
    // debug short: POIs currently visible, other sat message, flare status\par
    DebugVecShort[0]  = (short)(tstep*10);            //Timestamp\par
    DebugVecShort[13] = game->getMirrorTimeRemaining();\par
    DebugVecShort[14] = challInfo.me.mirrorTime;\par
\par
    //items\par
    for (int i = 0; i < NUM_ITEMS; i++)\{\par
      DebugVecShort[i + 1] = (unsigned short) challInfo.me.mpTime[i];\par
    \}\par
\par
    DebugVecShort[15] = challInfo.me.message;                   //message sent between players\par
\par
    // unsigned short debug packet: status of game variables, known flare times\par
    DebugVecUShort[0] = (unsigned short)(tstep*10); //Timestamp\par
\par
\par
    DebugVecUShort[7] = (unsigned short) (sphereInLight(challInfo.me.zrState));\par
    DebugVecUShort[7] <<= 1;\par
    DebugVecUShort[7] += (unsigned short) (sphereInDark(challInfo.me.zrState));\par
\par
    DebugVecUShort[8] = (challInfo.light.direction > 0);\par
    DebugVecUShort[9] = (unsigned short) (challInfo.camera.tookPicture);\par
    DebugVecUShort[10] = (unsigned short) (challInfo.camera.uploadedPictures);\par
    DebugVecUShort[11] = (unsigned short) (challInfo.camera.cameraOn);\par
    DebugVecUShort[13] = (unsigned short) (challInfo.camera.memorySize);\par
    DebugVecUShort[14] = (unsigned short) (challInfo.camera.memoryFilled);\par
\par
    //Float debug packet: score, fuel, forces\par
    DebugVecFloat[0] = (float)tstep;\par
    DebugVecFloat[1] = game->getScore();\par
    DebugVecFloat[2] = game->getFuelRemaining() / ((double)PROP_ALLOWED_SECONDS);\par
    DebugVecFloat[3] = challInfo.me.energy;\par
    DebugVecFloat[4] = challInfo.light.center;\par
\par
    memcpy(&DebugVecFloat[5], challInfo.me.userForces, 3*sizeof(float)); //Forces for reference\par
\par
    //Send packets to other SPHERES/ground/sim; do not modify below this line\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_SHORT_SIGNED, (unsigned char *) DebugVecShort,0);\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_FLOAT, (unsigned char *) DebugVecFloat,0);\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_SHORT_UNSIGNED, (unsigned char *) DebugVecUShort,0);\par
\par
  #ifdef ZRSIMULATION\par
    apiImpl.ZRUserDbgVec[0] = (float)tstep;\par
    commSendPacket(COMM_CHANNEL_STL, GROUND, sysIdentityGet(), COMM_CMD_DBG_ZRUSER, (unsigned char *) apiImpl.ZRUserDbgVec,0);\par
  #endif\par
  \}\par
\}\par
}
}
{\xe \v sendInit\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sendInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::sendInit} (void )}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for Corona SPHERES: sends POI & Solar Flare info to Sat 2 at start of game }}\par
{
Definition at line 166 of file ZRCommRoutines.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  #if (SPHERE_ID == SPHERE1)\par
      dbg_short_packet DebugVecShort;\par
      dbg_ushort_packet DebugVecUShort;\par
      dbg_float_packet DebugVecFloat;\par
\par
    // sends light information to second satellite\par
    memset(DebugVecShort,  0, sizeof(dbg_short_packet));    // initialize packets to 0\par
    memset(DebugVecUShort,  0, sizeof(dbg_ushort_packet));\par
    memset(DebugVecFloat,  0, sizeof(dbg_float_packet));\par
\par
    DebugVecShort[0] = 0;\par
\par
    int upTo = 5;\par
    if (NUM_ITEMS < upTo) \{\par
      upTo = NUM_ITEMS;\par
    \}\par
\par
    for (int i = 0; i < upTo; i++) \{\par
      DebugVecShort[3*i + 1] = 10000 * challInfo.mpLoc[i][0];\par
      DebugVecShort[3*i + 2] = 10000 * challInfo.mpLoc[i][1];\par
      DebugVecShort[3*i + 3] = 10000 * challInfo.mpLoc[i][2];\par
    \}\par
\par
    DebugVecUShort[0] = 0;\par
    DebugVecUShort[1] = (short)0 + (challInfo.light.nextSwitchTime);\par
\par
    #ifdef ALLIANCE\par
      DebugVecUShort[2] = 3;\par
    #else\par
      #ifdef ZR3D\par
        DebugVecUShort[2] = 2;\par
      #else\par
        #ifdef ZR2D\par
          DebugVecUShort[2] = 1;\par
        #else\par
          DebugVecUShort[2] = 0;\par
        #endif\par
      #endif\par
    #endif\par
\par
    DebugVecUShort[3] = NUM_ITEMS;\par
\par
    for (int i = 0; i < NUM_ITEMS; i++)\par
    \{\par
      DebugVecUShort[4 + i] = ITEM_TYPES[i];\par
    \}\par
\par
      DebugVecFloat[0] = 0.0f;\par
      DebugVecFloat[1] = challInfo.light.center;\par
      DebugVecFloat[2] = challInfo.light.direction;\par
\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_SHORT_SIGNED, (unsigned char *) DebugVecShort,0);\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_SHORT_UNSIGNED, (unsigned char *) DebugVecUShort,0);\par
    commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_FLOAT, (unsigned char *) DebugVecFloat,0);\par
  #endif\par
  #if (SPHERE_ID == SPHERE2)\par
      dbg_short_packet DebugVecShort;\par
      DebugVecShort[0] = 0;\par
\par
      for (int i = 0; i < NUM_ITEMS - 5; i++)\par
      \{\par
        DebugVecShort[3*i + 1] = 10000 * challInfo.mpLoc[i+5][0];\par
        DebugVecShort[3*i + 2] = 10000 * challInfo.mpLoc[i+5][1];\par
        DebugVecShort[3*i + 3] = 10000 * challInfo.mpLoc[i+5][2];\par
      \}\par
\par
      commSendPacket(COMM_CHANNEL_STL, BROADCAST, 0, COMM_CMD_DBG_SHORT_SIGNED, (unsigned char *) DebugVecShort,0);\par
  #endif\par
\}\par
}
}
{\xe \v sphereInDark\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sphereInDark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::sphereInDark} (float {\i position}[])}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                         \{\par
  #ifdef ALLIANCE\par
  return sphereInMovingArea(position) == -1;\par
  #else\par
  return sphereInSwitchingArea(position) == -1;\par
  #endif\par
\}\par
}
}
{\xe \v sphereInLight\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sphereInLight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::sphereInLight} (float {\i position}[])}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 95 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                          \{\par
  #ifdef ALLIANCE\par
  return sphereInMovingArea(position) == 1;\par
  #else\par
  return sphereInSwitchingArea(position) == 1;\par
  #endif\par
\}\par
}
}
{\xe \v sphereInMovingArea\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sphereInMovingArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::sphereInMovingArea} (float {\i position}[])}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
\par
  float interface = challInfo.light.center; // Start of Light Zone\par
  float outerface = interface + challInfo.light.lightWidth; // End of light zone\par
  if(outerface > ZONE_pY)\par
    outerface -= 2*ZONE_pY; // Wraparound\par
  float halfWidth = challInfo.light.greyWidth*.5; // Grey width on either side\par
  if ((interface - halfWidth <= position[1] && interface + halfWidth >= position[1]) || // In the first grey zone\par
      (outerface - halfWidth <= position[1] && outerface + halfWidth >= position[1]) || // In the second gray zone\par
      (position[0] >= ZONE_pX || position[1] >= ZONE_pY || position[2] >= ZONE_pZ) || // Out of bounds positive\par
      (position[0] <= ZONE_nX || position[1] <= ZONE_nY || position[2] <= ZONE_nZ)) // Out of bounds negatively\par
  \{\par
    return 0; // Gray \par
  \}\par
  else if ((outerface > position[1] && (interface < position[1] || outerface < interface)) || // before the end of the light zone and Either after the beginning or the end has wrapped around\par
          (interface < position[1] && outerface < interface))  // or it's after the beginning and the end has wrapped\par
  \{\par
    return 1; //Light\par
  \}\par
\par
  return -1; // Dark\par
\}\par
}
}
{\xe \v sphereInSwitchingArea\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:sphereInSwitchingArea}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b ZeroRoboticsGameImpl::sphereInSwitchingArea} (float {\i position}[])}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                                 \{\par
  float center = challInfo.light.center;\par
  float diff = position[1] - center;\par
  diff *= challInfo.light.direction; // adjust for light direction\par
\par
  if (diff > -challInfo.light.greyWidth/2 && diff < challInfo.light.greyWidth/2) return 0;\par
  if (diff < 0) return -1;\par
  return 1;\par
\}\par
}
}
{\xe \v switchLightDirection\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:switchLightDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::switchLightDirection} ()}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                 \{\par
  challInfo.light.direction *= -1;\par
\}\par
}
}
{\xe \v takePicImpl\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:takePicImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b ZeroRoboticsGameImpl::takePicImpl} ()}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the score value of the picture, or 0 if taking the picture failed. }}\par
{
Definition at line 128 of file ZRCamera.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
\par
  challInfo.me.score += 0.01f;\par
  GAME_TRACE(("[%d] attempting to take picture... ", challInfo.currentTime));\par
\par
  bool enoughSpace = challInfo.camera.memoryFilled < challInfo.camera.memorySize;\par
\par
\par
  // uses the energy even if the picture can't be taken\par
  // (if not enough space or not facing other sphere)\par
  bool usedEnergy = tryToUseEnergy(ENERGY_COST_TAKE_PICTURE);\par
\par
  float pictureValue = picPointsImpl();\par
\par
  if(enoughSpace && usedEnergy && pictureValue != 0)     // check if it can take a picture\par
  \{\par
    challInfo.camera.tookPicture = true;\par
    // apply score modifiers etc\par
    challInfo.me.score += 0.1f;         // Very small value. Subject to change.\par
    challInfo.camera.memory[challInfo.camera.memoryFilled].picStored = true;\par
\par
    challInfo.camera.memory[challInfo.camera.memoryFilled].value = pictureValue;\par
    // End of scoring\par
\par
    challInfo.camera.memory[challInfo.camera.memoryFilled].round = 1;\par
\par
\par
    challInfo.camera.memoryFilled++;\par
\par
\par
    GAME_TRACE(("[%d] took picture (round %d) valued %4.2f points | ", apiImpl.api->getTime(), challInfo.camera.memory[challInfo.camera.memoryFilled-1].round, challInfo.camera.memory[challInfo.camera.memoryFilled-1].value));\par
\par
  \}\par
   else if(!enoughSpace && pictureValue != 0 )\{\par
    GAME_TRACE(("Failed to take a picture: memory filled up | "));\par
  \}\par
   else if(!usedEnergy && pictureValue != 0 )\{\par
    GAME_TRACE(("Failed to take a picture: not enough energy | "));\par
  \}\par
\par
  disableCamera();\par
\par
  return pictureValue;\par
\}\par
}
}
{\xe \v tryToUseEnergy\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:tryToUseEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::tryToUseEnergy} (float {\i amount})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file ZREnergy.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if (amount < 0) \{\par
    GAME_TRACE(("DEV: trying to use negative energy. Check for bugs. | "));\par
    return false;\par
  \}\par
\par
  if (amount > challInfo.me.energy) \{\par
    // GAME_TRACE(("Not enough energy to perform the action. | "));\par
    return false;\par
  \}\par
\par
  challInfo.me.energy -= amount;\par
  return true;\par
\}\par
}
}
{\xe \v update\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::update} (float {\i forceTorqueOut}[6])}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs an update of the game rules and calls the user function loop(). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The return value for this function indicates if the forceTorqueOut vector should be mixed into thruster firings. The function should return 0 if the user does not activate any ZR API movement commands or implements their own thruster firing logic.\par
Here we update player's scores\par
/param forceTorqueOut forces and torques to be mixed into thruster firings /return return 1 if forceTorqueOut should be mixed into thruster firings and 0 otherwise \par
}{
Definition at line 110 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                          \{\par
  updateStates();\par
  updateLight();\par
  updateEnergy();\par
\par
  // empty the userForces array\par
  memset(challInfo.me.userForces,0,sizeof(float)*6);\par
\par
  // declare a static finalResult variable\par
  // updateGameOverManuever will change it\par
  static unsigned char finalResult = 0;\par
\par
  unsigned char useForces = false;\par
\par
  // maneuver 3 = game mode\par
  // maneuver 202 = end game (get final score)\par
  // maneuver 204 = terminate\par
\par
  switch (ctrlManeuverNumGet())\par
  \{\par
\par
    case 3:\par
      useForces = updateGameModeManeuver(forceTorqueOut);\par
      break;\par
\par
    //------End main game code------//\par
\par
    case 202: // Endgame scenario\par
      useForces = updateGameOverManeuver(forceTorqueOut, finalResult);\par
      break;\par
\par
    case 203: // terminate test after determining final score\par
      \{\par
        ctrlTestTerminate(finalResult);\par
      \}\par
      break;\par
  \}\par
\par
  //Store user forces for sending to ground\par
  memcpy(challInfo.me.userForces, forceTorqueOut, sizeof(float)*6);\par
\par
#ifdef ZR2D\par
  memset(&challInfo.me.userForces[2], 0, sizeof(float)*3);\par
#endif\par
\par
  //Send Telemetry\par
  sendDebug();\par
\par
  return useForces;\par
\par
\}\par
}
}
{\xe \v updateEnergy\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:updateEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::updateEnergy} ()}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file ZREnergy.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                         \{\par
  if (!sphereInLight(challInfo.me.zrState)) return;\par
\par
  challInfo.me.energy += ENERGY_GAIN_RATE;\par
  if (challInfo.me.energy > MAX_ENERGY) \{\par
    challInfo.me.energy = MAX_ENERGY;\par
  \}\par
\}\par
}
}
{\xe \v updateGameModeManeuver\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:updateGameModeManeuver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::updateGameModeManeuver} (float {\i forceTorqueOut}[6])}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 231 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                                          \{\par
  float collisionInfo[2];\par
\par
  // get state-of-health of other satellite (mainly for end of test)\par
  comm_payload_soh soh_partner;\par
  #if (SPHERE_ID == SPHERE1)\par
    commBackgroundSOHGet(SPHERE2, &soh_partner);\par
  #else\par
    commBackgroundSOHGet(SPHERE1, &soh_partner);\par
  #endif\par
\par
  // determine current speed of satellite, use to determine collision avoidance motion\par
  float speed = mathVecMagnitude(&challInfo.me.sphState[3],3);\par
\par
  unsigned char useForces = false;\par
\par
  // if camera was used (so it can't be used again for 3 seconds), check when to enable it again\par
  if((!challInfo.camera.cameraOn) && ((challInfo.currentTime - challInfo.camera.cameraOffTime) > DISABLE_CAMERA_TIME))\par
  \{\par
    activateCamera();\par
  \}\par
\par
  // Run user's "loop" function.  apiImpl is used because we are accessing\par
  // a private part of the API containing a pointer to the user's API\par
  apiImpl.zruser->loop();\par
\par
  //Check if items are being picked up\par
  for (int i = 0; i < NUM_ITEMS; i++)\par
    itemPickUp(i);\par
\par
  useForces = useForces || apiImpl.getForceTorque(forceTorqueOut);\par
  \par
  prop_time tent_times;\par
  #ifdef ZRFLATFLOOR\par
    ctrlMixWLoc(&tent_times, forceTorqueOut, challInfo.me.sphState, 10, 40.0f, FORCE_FRAME_INERTIAL);\par
  #else\par
    ctrlMixWLoc(&tent_times, forceTorqueOut, challInfo.me.sphState, 10, 20.0f, FORCE_FRAME_INERTIAL);\par
  #endif\par
\par
  float tent_time_sum = 0;\par
  for (int i = 0; i < 12; i++) \{\par
    tent_time_sum += tent_times.off_time[i]-tent_times.on_time[i];\par
  \}\par
\par
  //Check for fuel or energy out at this point\par
  if((game->getFuelRemaining() <= 0.0f || game->getEnergy() <= tent_time_sum * ENERGY_COST_THRUSTERS))\par
  \{\par
    memset(forceTorqueOut,0,6*sizeof(float));   // anything the user has commanded is ignored, only firings would be from out-of-bounds or collission avoidance\par
    useForces = false;  // assume there will be no firings\par
  \}\par
\par
  //Enforce boundaries of the game\par
  if (enforceBoundaries(forceTorqueOut))\par
  \{\par
    //challInfo.me.fuelUsed += OFFSIDES_PENALTY;\par
    GAME_TRACE(("[%d] out of bounds penalty | ", apiImpl.api->getTime()));\par
    useForces = true;\par
  \}\par
\par
  //Collision avoidance\par
  //check to see that its speed is not neglible.\par
  if (speed > 0.01f) \{\par
    challInfo.me.collisionActive = ctrlAvoidWithOverride(challInfo.me.sphState,&challInfo.other.sphState,1,forceTorqueOut,collisionInfo,3);\par
  \}\par
\par
  //------Thruster control------//\par
    // Run standard mixer to get fuel consumption\par
  prop_time times;\par
  ctrlMixWLoc(&times, forceTorqueOut, challInfo.me.sphState, 10, 20.0f, FORCE_FRAME_INERTIAL);\par
\par
  //Tally fuel and energy used for firing thrusters\par
  for (int i=0; i<12; i++)\par
  \{\par
    float thrusterTime = times.off_time[i]-times.on_time[i];\par
\par
    challInfo.me.fuelUsed += thrusterTime / 1000.0f;\par
\par
    tryToUseEnergy(thrusterTime * ENERGY_COST_THRUSTERS);\par
\par
\par
    //Protect against NAN or INF hacking\par
    if (challInfo.me.fuelUsed < 0.0f)\par
    \{\par
      DEBUG(("WARNING: invalid forces/torques applied to satellite at t=%d. Fuel will be set to 0. Check your code for errors.\\n", challInfo.currentTime));\par
      challInfo.me.fuelUsed = PROP_ALLOWED_SECONDS;\par
    \}\par
  \}\par
  \par
  #ifdef ZR2D\par
    modify2DForceTorque(forceTorqueOut);\par
    useForces = true;\par
  #endif\par
\par
  //------Game end conditions------//\par
  if (challInfo.currentTime >= (MAX_GAME_TIME))\par
    ctrlManeuverNumSet(202);\par
\par
  return useForces;\par
\}\par
}
}
{\xe \v updateGameOverManeuver\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:updateGameOverManeuver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b ZeroRoboticsGameImpl::updateGameOverManeuver} (float {\i forceTorqueOut}[6], unsigned char & {\i finalScore})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 331 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                                                                                      \{\par
  unsigned char useForces = false;\par
  int result;\par
\par
  float collisionInfo[2];\par
\par
  // get state-of-health of other satellite (mainly for end of test)\par
  comm_payload_soh soh_partner;\par
  #if (SPHERE_ID == SPHERE1)\par
    commBackgroundSOHGet(SPHERE2, &soh_partner);\par
  #else\par
    commBackgroundSOHGet(SPHERE1, &soh_partner);\par
  #endif\par
\par
  float myScore;\par
  float otherScore;\par
\par
  myScore = game->getScore();\par
  otherScore = game->getOtherScore();\par
\par
  useForces = ctrlAvoidWithOverride(challInfo.me.sphState, &challInfo.other.sphState, 1, forceTorqueOut, collisionInfo, 3) > 0;\par
  useForces = useForces || enforceBoundaries(forceTorqueOut);\par
\par
  // break ties by making a tiny change based on the random state\par
  if (myScore == otherScore)\par
  \{\par
    challInfo.me.score  -= (0.01f * sqrtf((challInfo.me.zrState[0]*challInfo.me.zrState[0])\par
      +(challInfo.me.zrState[1]*challInfo.me.zrState[1])+(challInfo.me.zrState[2]*challInfo.me.zrState[2])));\par
    GAME_TRACE (("Tie Breaker (%12.10f = %12.10f), new score = %12.10f | ", myScore, otherScore, challInfo.me.score));\par
  \}\par
\par
  // get final score\par
  if ((soh_partner.last_test_result || (soh_partner.maneuver_number > 200) || (NUM_SPHERES == 1)))\par
  \{\par
    result = 10*floorf(myScore);\par
    if (result < 10) result = 10;\par
    if (result > 220) result = 220;\par
    if (myScore > otherScore)\par
      result += 10;\par
    finalResult = (result + apiImpl.getTeamId() + 1);\par
    useForces = false;\par
  \}\par
\par
  // terminate after we find the final result & timeout (4s)\par
  if (finalResult && (ctrlManeuverTimeGet() > 4000))\par
  \{\par
    GAME_TRACE (("GAME ENDED! Final Score Float: %10.8f / Integer: %d | Test Result %d | ", myScore, result, finalResult));\par
    ctrlManeuverTerminate();\par
  \}\par
  return useForces;\par
\}\par
}
}
{\xe \v updateLight\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:updateLight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::updateLight} ()}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file ZRLight.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                        \{\par
  #ifdef ALLIANCE\par
\par
    challInfo.light.center += LIGHT_SPEED;\par
    if (challInfo.light.center > ZONE_pY) \{\par
      challInfo.light.center -= 2*ZONE_pY;\par
    \}\par
\par
  #else\par
\par
    if (challInfo.currentTime < challInfo.light.nextSwitchTime) return;\par
\par
    GAME_TRACE(("Light switching now"));\par
    switchLightDirection();\par
    challInfo.light.nextSwitchTime = challInfo.currentTime + LIGHT_SWITCH_PERIOD;\par
\par
  #endif\par
\}\par
}
}
{\xe \v updateStates\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:updateStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b ZeroRoboticsGameImpl::updateStates} ()}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 97 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                         \{\par
  apiImpl.api->getMyZRState(challInfo.me.zrState);\par
  apiImpl.api->getOtherZRState(challInfo.other.zrState);\par
\par
  apiImpl.api->getMySphState(challInfo.me.sphState);\par
  apiImpl.api->getOtherSphState(challInfo.other.sphState);\par
\par
  challInfo.currentTime = apiImpl.api->getTime();\par
\par
  challInfo.camera.tookPicture = false;\par
  challInfo.camera.uploadedPictures = false;\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v apiImpl\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:apiImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ZeroRoboticsAPIImpl& {\b ZeroRoboticsGameImpl::apiImpl}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reference to ZR API instance. }}\par
{
Definition at line 224 of file ZRGameInternal.h.}\par
}
{\xe \v challInfo\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:challInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ChallengeInfo} {\b ZeroRoboticsGameImpl::challInfo}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file ZRGameInternal.h.}\par
}
{\xe \v game\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGame}* {\b ZeroRoboticsGameImpl::game}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Back pointer to the game instance. }}\par
{
Definition at line 227 of file ZRGameInternal.h.}\par
}
{\xe \v initState\:ZeroRoboticsGameImpl}
{\xe \v ZeroRoboticsGameImpl\:initState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const state_vector {\b ZeroRoboticsGameImpl::initState}{\f2  [static]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Initial state where the satellite is initialized. }}\par
{
Definition at line 162 of file ZRGameInternal.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRCamera.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRCommRoutines.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZREnergy.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRGameInternal.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRItems.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ZRLight.cpp}\par
}
\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Constants.h File Reference\par \pard\plain 
{\tc\tcl2 \v Constants.h}
{\xe \v Constants.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A list of constants used in the ZR program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "math_matrix.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLIANCE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHOW_GAME_TRACE}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GAME_TIME}\~ 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The time at game start. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VEL_X}\~ 3\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The index for the beginning of the velocity array inside of ZRState. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_GAME_TIME}\~ 180\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of the whole game in seconds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FACING_ANGLE}\~ 0.968912f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cosine of the angle at which pictures may be taken/uploaded. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UPLOAD_ANG_VEL}\~ 0.05f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum speed at which pictures can be uploaded in rads/s, which is roughly equal to 2.8 deg/s. This is calculated by taking the absolute value of the magnitude of the attitude rate vector. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_TYPE_ADD_SCORE}\~ 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for a score item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_TYPE_ADD_ENERGY}\~ 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for an energy item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_TYPE_MIRROR}\~ 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for a mirror. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_SCORE}\~ 1.5f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The added score given by a score item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_ENERGY}\~ {\b MAX_ENERGY}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The added energy given by an energy item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ITEM_MIRROR_DURATION}\~ 24\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The length a mirror lasts once activated. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NUM_ITEMS}\~ 9\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of items in the game. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STARTING_MIRRORS}\~ 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of mirrors each sphere starts with. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MP_SPEED}\~ 0.01f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum speed at which an item may be picked up. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MP_RADIUS}\~ 0.05f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum distance from which an item may be picked up. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MP_ROTATION_ANGLE}\~ 0.707106f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(rad) Rotation of satellite needed to pick up item (cos(90/2)) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MP_EMPTY}\~ 0x0fff\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIGHT_SWITCH_PERIOD}\~ 60\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The light switches this number of seconds after the first flip in the 2D/3D versions of the game. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIGHT_SPEED}\~ .025f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The light moves at this speed (in m/s) during the Alliance portion of the game. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIGHT_WIDTH}\~ .8\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The width of the area that is not dark. Note that this includes the grey zone. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIGHT_GREY_WIDTH}\~ .2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The width of the grey zone in the 2D/3D versions. The width of each grey zone in Alliance is LIGHT_GREY_WIDTH/2. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DISABLE_CAMERA_TIME}\~ 3\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The camera is disabled for this many seconds after taking and uploading pictures. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CAMERA_DEFAULT_MEMORY}\~ 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of memory slots an unmodified camera has. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CAMERA_MAX_MEMORY}\~ 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of memory slots the camera may have at a maximum. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PHOTO_MIN_DISTANCE}\~ 0.5\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum distance the sphere may be from the target of its photograph. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_FUEL}(a, b)\~ ((a < b) ? b : a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FUEL}(c, d)\~ ((c < d) ? c : d)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PROP_ALLOWED_SECONDS}\~ 60.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total time in thruster-seconds allowed per user. Full tank ~500 seconds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_ENERGY}\~ 5.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Energy capacity. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STARTING_ENERGY}\~ {\b MAX_ENERGY}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starting energy. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_GAIN_RATE}\~ 0.5f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Energy gained per second. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_COST_TAKE_PICTURE}\~ 1.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to take a picture. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_COST_GET_OTHER_ENERGY}\~ 0.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to determine how much energy your opponent has. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_COST_GET_PIC_POINTS}\~ 0.1f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to determine how many points taking a picture right now would be worth, should you choose to take it. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_COST_UPLOAD_PICTURES}\~ 1.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to upload pictures. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENERGY_COST_THRUSTERS}\~ (.001f)*(.3f)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to use one thousandth of a second of fuel. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OFFSIDES_PENALTY}\~ .02*{\b PROP_ALLOWED_SECONDS}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OOBgain}\~ 10.0f\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DRAG}\~ 1000.0f\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b START_SCORE}\~ 0.0f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Your score upon starting the game. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_pX}\~ 0.64f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest X coordinate in bounds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_pY}\~ 0.80f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest Y coordinate in bounds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_pZ}\~ 0.64f\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest Z coordinate in bounds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_nX}\~ -{\b ZONE_pX}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest X coordinate in bounds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_nY}\~ -{\b ZONE_pY}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest Y coordinate in bounds. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZONE_nZ}\~ -{\b ZONE_pZ}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest Z coordinate in bounds. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b EARTH} [3] = \{0.0f, 0.0f, 1.0f\}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the attitude towards Earth. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b ITEM_TYPES} [{\b NUM_ITEMS}]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array that outlines the types of each item. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const float {\b limits} [3] = \{{\b ZONE_pX},{\b ZONE_pY},{\b ZONE_pZ}\}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The limits of the interaction zone. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A list of constants used in the ZR program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition in file {\b Constants.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v ALLIANCE\:Constants.h}
{\xe \v Constants.h\:ALLIANCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ALLIANCE}}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file Constants.h.}\par
}
{\xe \v CAMERA_DEFAULT_MEMORY\:Constants.h}
{\xe \v Constants.h\:CAMERA_DEFAULT_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b CAMERA_DEFAULT_MEMORY}\~ 2}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of memory slots an unmodified camera has. }}\par
{
Definition at line 199 of file Constants.h.}\par
}
{\xe \v CAMERA_MAX_MEMORY\:Constants.h}
{\xe \v Constants.h\:CAMERA_MAX_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b CAMERA_MAX_MEMORY}\~ 4}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of memory slots the camera may have at a maximum. }}\par
{
Definition at line 200 of file Constants.h.}\par
}
{\xe \v DISABLE_CAMERA_TIME\:Constants.h}
{\xe \v Constants.h\:DISABLE_CAMERA_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b DISABLE_CAMERA_TIME}\~ 3}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The camera is disabled for this many seconds after taking and uploading pictures. }}\par
{
Definition at line 198 of file Constants.h.}\par
}
{\xe \v DRAG\:Constants.h}
{\xe \v Constants.h\:DRAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b DRAG}\~ 1000.0f}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 226 of file Constants.h.}\par
}
{\xe \v ENERGY_COST_GET_OTHER_ENERGY\:Constants.h}
{\xe \v Constants.h\:ENERGY_COST_GET_OTHER_ENERGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_COST_GET_OTHER_ENERGY}\~ 0.0f}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to determine how much energy your opponent has. }}\par
{
Definition at line 215 of file Constants.h.}\par
}
{\xe \v ENERGY_COST_GET_PIC_POINTS\:Constants.h}
{\xe \v Constants.h\:ENERGY_COST_GET_PIC_POINTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_COST_GET_PIC_POINTS}\~ 0.1f}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to determine how many points taking a picture right now would be worth, should you choose to take it. }}\par
{
Definition at line 216 of file Constants.h.}\par
}
{\xe \v ENERGY_COST_TAKE_PICTURE\:Constants.h}
{\xe \v Constants.h\:ENERGY_COST_TAKE_PICTURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_COST_TAKE_PICTURE}\~ 1.0f}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to take a picture. }}\par
{
Definition at line 214 of file Constants.h.}\par
}
{\xe \v ENERGY_COST_THRUSTERS\:Constants.h}
{\xe \v Constants.h\:ENERGY_COST_THRUSTERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_COST_THRUSTERS}\~ (.001f)*(.3f)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to use one thousandth of a second of fuel. }}\par
{
Definition at line 220 of file Constants.h.}\par
}
{\xe \v ENERGY_COST_UPLOAD_PICTURES\:Constants.h}
{\xe \v Constants.h\:ENERGY_COST_UPLOAD_PICTURES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_COST_UPLOAD_PICTURES}\~ 1.0f}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The energy cost to upload pictures. }}\par
{
Definition at line 219 of file Constants.h.}\par
}
{\xe \v ENERGY_GAIN_RATE\:Constants.h}
{\xe \v Constants.h\:ENERGY_GAIN_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ENERGY_GAIN_RATE}\~ 0.5f}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Energy gained per second. }}\par
{
Definition at line 213 of file Constants.h.}\par
}
{\xe \v GAME_TIME\:Constants.h}
{\xe \v Constants.h\:GAME_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b GAME_TIME}\~ 0}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The time at game start. }}\par
{
Definition at line 45 of file Constants.h.}\par
}
{\xe \v ITEM_ENERGY\:Constants.h}
{\xe \v Constants.h\:ITEM_ENERGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_ENERGY}\~ {\b MAX_ENERGY}}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The added energy given by an energy item. }}\par
{
Definition at line 91 of file Constants.h.}\par
}
{\xe \v ITEM_MIRROR_DURATION\:Constants.h}
{\xe \v Constants.h\:ITEM_MIRROR_DURATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_MIRROR_DURATION}\~ 24}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The length a mirror lasts once activated. }}\par
{
Definition at line 92 of file Constants.h.}\par
}
{\xe \v ITEM_SCORE\:Constants.h}
{\xe \v Constants.h\:ITEM_SCORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_SCORE}\~ 1.5f}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The added score given by a score item. }}\par
{
Definition at line 90 of file Constants.h.}\par
}
{\xe \v ITEM_TYPE_ADD_ENERGY\:Constants.h}
{\xe \v Constants.h\:ITEM_TYPE_ADD_ENERGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_TYPE_ADD_ENERGY}\~ 1}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for an energy item. }}\par
{
Definition at line 87 of file Constants.h.}\par
}
{\xe \v ITEM_TYPE_ADD_SCORE\:Constants.h}
{\xe \v Constants.h\:ITEM_TYPE_ADD_SCORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_TYPE_ADD_SCORE}\~ 0}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for a score item. }}\par
{
Definition at line 86 of file Constants.h.}\par
}
{\xe \v ITEM_TYPE_MIRROR\:Constants.h}
{\xe \v Constants.h\:ITEM_TYPE_MIRROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ITEM_TYPE_MIRROR}\~ 2}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The type identifier for a mirror. }}\par
{
Definition at line 88 of file Constants.h.}\par
}
{\xe \v LIGHT_GREY_WIDTH\:Constants.h}
{\xe \v Constants.h\:LIGHT_GREY_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b LIGHT_GREY_WIDTH}\~ .2}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The width of the grey zone in the 2D/3D versions. The width of each grey zone in Alliance is LIGHT_GREY_WIDTH/2. }}\par
{
Definition at line 193 of file Constants.h.}\par
}
{\xe \v LIGHT_SPEED\:Constants.h}
{\xe \v Constants.h\:LIGHT_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b LIGHT_SPEED}\~ .025f}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The light moves at this speed (in m/s) during the Alliance portion of the game. }}\par
{
Definition at line 191 of file Constants.h.}\par
}
{\xe \v LIGHT_SWITCH_PERIOD\:Constants.h}
{\xe \v Constants.h\:LIGHT_SWITCH_PERIOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b LIGHT_SWITCH_PERIOD}\~ 60}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The light switches this number of seconds after the first flip in the 2D/3D versions of the game. }}\par
{
Definition at line 190 of file Constants.h.}\par
}
{\xe \v LIGHT_WIDTH\:Constants.h}
{\xe \v Constants.h\:LIGHT_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b LIGHT_WIDTH}\~ .8}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The width of the area that is not dark. Note that this includes the grey zone. }}\par
{
Definition at line 192 of file Constants.h.}\par
}
{\xe \v MAX_ENERGY\:Constants.h}
{\xe \v Constants.h\:MAX_ENERGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MAX_ENERGY}\~ 5.0f}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Energy capacity. }}\par
{
Definition at line 211 of file Constants.h.}\par
}
{\xe \v MAX_FACING_ANGLE\:Constants.h}
{\xe \v Constants.h\:MAX_FACING_ANGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b MAX_FACING_ANGLE}\~ 0.968912f}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cosine of the angle at which pictures may be taken/uploaded. }}\par
{
Definition at line 73 of file Constants.h.}\par
}
{\xe \v MAX_FUEL\:Constants.h}
{\xe \v Constants.h\:MAX_FUEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MAX_FUEL}( c,  d)\~ ((c < d) ? c : d)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 206 of file Constants.h.}\par
}
{\xe \v MAX_GAME_TIME\:Constants.h}
{\xe \v Constants.h\:MAX_GAME_TIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b MAX_GAME_TIME}\~ 180}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Length of the whole game in seconds. }}\par
{
Definition at line 66 of file Constants.h.}\par
}
{\xe \v MIN_FUEL\:Constants.h}
{\xe \v Constants.h\:MIN_FUEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MIN_FUEL}( a,  b)\~ ((a < b) ? b : a)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 205 of file Constants.h.}\par
}
{\xe \v MP_EMPTY\:Constants.h}
{\xe \v Constants.h\:MP_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MP_EMPTY}\~ 0x0fff}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 187 of file Constants.h.}\par
}
{\xe \v MP_RADIUS\:Constants.h}
{\xe \v Constants.h\:MP_RADIUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MP_RADIUS}\~ 0.05f}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum distance from which an item may be picked up. }}\par
{
Definition at line 184 of file Constants.h.}\par
}
{\xe \v MP_ROTATION_ANGLE\:Constants.h}
{\xe \v Constants.h\:MP_ROTATION_ANGLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MP_ROTATION_ANGLE}\~ 0.707106f}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(rad) Rotation of satellite needed to pick up item (cos(90/2)) }}\par
{
Definition at line 185 of file Constants.h.}\par
}
{\xe \v MP_SPEED\:Constants.h}
{\xe \v Constants.h\:MP_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b MP_SPEED}\~ 0.01f}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum speed at which an item may be picked up. }}\par
{
Definition at line 183 of file Constants.h.}\par
}
{\xe \v NUM_ITEMS\:Constants.h}
{\xe \v Constants.h\:NUM_ITEMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b NUM_ITEMS}\~ 9}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of items in the game. }}\par
{
Definition at line 93 of file Constants.h.}\par
}
{\xe \v OFFSIDES_PENALTY\:Constants.h}
{\xe \v Constants.h\:OFFSIDES_PENALTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b OFFSIDES_PENALTY}\~ .02*{\b PROP_ALLOWED_SECONDS}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 224 of file Constants.h.}\par
}
{\xe \v OOBgain\:Constants.h}
{\xe \v Constants.h\:OOBgain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b OOBgain}\~ 10.0f}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 225 of file Constants.h.}\par
}
{\xe \v PHOTO_MIN_DISTANCE\:Constants.h}
{\xe \v Constants.h\:PHOTO_MIN_DISTANCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b PHOTO_MIN_DISTANCE}\~ 0.5}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum distance the sphere may be from the target of its photograph. }}\par
{
Definition at line 202 of file Constants.h.}\par
}
{\xe \v PROP_ALLOWED_SECONDS\:Constants.h}
{\xe \v Constants.h\:PROP_ALLOWED_SECONDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b PROP_ALLOWED_SECONDS}\~ 60.0f}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total time in thruster-seconds allowed per user. Full tank ~500 seconds. }}\par
{
Definition at line 207 of file Constants.h.}\par
}
{\xe \v SHOW_GAME_TRACE\:Constants.h}
{\xe \v Constants.h\:SHOW_GAME_TRACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b SHOW_GAME_TRACE}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file Constants.h.}\par
}
{\xe \v START_SCORE\:Constants.h}
{\xe \v Constants.h\:START_SCORE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b START_SCORE}\~ 0.0f}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Your score upon starting the game. }}\par
{
Definition at line 231 of file Constants.h.}\par
}
{\xe \v STARTING_ENERGY\:Constants.h}
{\xe \v Constants.h\:STARTING_ENERGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b STARTING_ENERGY}\~ {\b MAX_ENERGY}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Starting energy. }}\par
{
Definition at line 212 of file Constants.h.}\par
}
{\xe \v STARTING_MIRRORS\:Constants.h}
{\xe \v Constants.h\:STARTING_MIRRORS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b STARTING_MIRRORS}\~ 0}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of mirrors each sphere starts with. }}\par
{
Definition at line 94 of file Constants.h.}\par
}
{\xe \v UPLOAD_ANG_VEL\:Constants.h}
{\xe \v Constants.h\:UPLOAD_ANG_VEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b UPLOAD_ANG_VEL}\~ 0.05f}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum speed at which pictures can be uploaded in rads/s, which is roughly equal to 2.8 deg/s. This is calculated by taking the absolute value of the magnitude of the attitude rate vector. }}\par
{
Definition at line 75 of file Constants.h.}\par
}
{\xe \v VEL_X\:Constants.h}
{\xe \v Constants.h\:VEL_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b VEL_X}\~ 3}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The index for the beginning of the velocity array inside of ZRState. }}\par
{
Definition at line 59 of file Constants.h.}\par
}
{\xe \v ZONE_nX\:Constants.h}
{\xe \v Constants.h\:ZONE_nX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_nX}\~ -{\b ZONE_pX}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest X coordinate in bounds. }}\par
{
Definition at line 242 of file Constants.h.}\par
}
{\xe \v ZONE_nY\:Constants.h}
{\xe \v Constants.h\:ZONE_nY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_nY}\~ -{\b ZONE_pY}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest Y coordinate in bounds. }}\par
{
Definition at line 243 of file Constants.h.}\par
}
{\xe \v ZONE_nZ\:Constants.h}
{\xe \v Constants.h\:ZONE_nZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_nZ}\~ -{\b ZONE_pZ}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The lowest Z coordinate in bounds. }}\par
{
Definition at line 244 of file Constants.h.}\par
}
{\xe \v ZONE_pX\:Constants.h}
{\xe \v Constants.h\:ZONE_pX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_pX}\~ 0.64f}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest X coordinate in bounds. }}\par
{
Definition at line 239 of file Constants.h.}\par
}
{\xe \v ZONE_pY\:Constants.h}
{\xe \v Constants.h\:ZONE_pY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_pY}\~ 0.80f}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest Y coordinate in bounds. }}\par
{
Definition at line 240 of file Constants.h.}\par
}
{\xe \v ZONE_pZ\:Constants.h}
{\xe \v Constants.h\:ZONE_pZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZONE_pZ}\~ 0.64f}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The highest Z coordinate in bounds. }}\par
{
Definition at line 241 of file Constants.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v EARTH\:Constants.h}
{\xe \v Constants.h\:EARTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float {\b EARTH}[3] = \{0.0f, 0.0f, 1.0f\}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the attitude towards Earth. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The satellite's attidude must be within MAX_FACING_ANGLE to this attitude \par
}{
Definition at line 31 of file Constants.h.}\par
}
{\xe \v ITEM_TYPES\:Constants.h}
{\xe \v Constants.h\:ITEM_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int {\b ITEM_TYPES}[{\b NUM_ITEMS}]}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
  \{\par
  ITEM_TYPE_ADD_ENERGY,\par
  ITEM_TYPE_ADD_ENERGY,\par
  ITEM_TYPE_ADD_ENERGY,\par
  ITEM_TYPE_ADD_SCORE,\par
  ITEM_TYPE_ADD_SCORE,\par
  ITEM_TYPE_ADD_SCORE,\par
  ITEM_TYPE_ADD_SCORE,\par
  ITEM_TYPE_MIRROR,\par
  ITEM_TYPE_MIRROR\par
  \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array that outlines the types of each item. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Usage: ITEM_TYPES[int ItemID] Each element is an integer that refers to one of the previously defined item types. \par
}{
Definition at line 127 of file Constants.h.}\par
}
{\xe \v limits\:Constants.h}
{\xe \v Constants.h\:limits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const float {\b limits}[3] = \{{\b ZONE_pX},{\b ZONE_pY},{\b ZONE_pZ}\}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The limits of the interaction zone. }}\par
{
Definition at line 246 of file Constants.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gsp.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v gsp.cpp}
{\xe \v gsp.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "comm.h"}\par
{\f2 #include "commands.h"}\par
{\f2 #include "control.h"}\par
{\f2 #include "gsp.h"}\par
{\f2 #include "gsp_task.h"}\par
{\f2 #include "gsp_internal.h"}\par
{\f2 #include "pads.h"}\par
{\f2 #include "prop.h"}\par
{\f2 #include "spheres_constants.h"}\par
{\f2 #include "spheres_physical_parameters.h"}\par
{\f2 #include "spheres_types.h"}\par
{\f2 #include "std_includes.h"}\par
{\f2 #include "system.h"}\par
{\f2 #include "util_memory.h"}\par
{\f2 #include "gsutil_checkout.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
{\f2 #include "ZRGame.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKOUT_TESTNUM_OFFSET}\~ (000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ZERROBOTICS_TESTNUM_OFFSET}\~ (100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b localPacket}\~ packet\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _test_class} {\b test_class}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _test_class} \{ {\b invalid_test}, 
{\b checkout_tests}, 
{\b zerorobotics_tests}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b test_class} {\b get_test_class} (unsigned int test_num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspIdentitySet} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspInitProgram} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspInitTest} (unsigned int test_number)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspInitTask} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspPadsInertial} (IMU_sample *accel, IMU_sample *gyro, unsigned int num_samples)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspPadsGlobal} (unsigned int beacon, beacon_measurement_matrix measurements)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspTaskRun} (unsigned int gsp_task_trigger, unsigned int extra_data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspControl} (unsigned int test_number, unsigned int test_time, unsigned int maneuver_number, unsigned int maneuver_time)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gspProcessRXData} (default_rfm_packet packet)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned int {\b refTestNumber} [] = \{101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 199\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b testclass}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b testnum} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b ZeroRoboticsGameImpl} & {\b gameImplRef} = {\b ZeroRoboticsGameImpl::instance}()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v CHECKOUT_TESTNUM_OFFSET\:gsp.cpp}
{\xe \v gsp.cpp\:CHECKOUT_TESTNUM_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b CHECKOUT_TESTNUM_OFFSET}\~ (000)}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file gsp.cpp.}\par
}
{\xe \v localPacket\:gsp.cpp}
{\xe \v gsp.cpp\:localPacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b localPacket}\~ packet}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ZERROBOTICS_TESTNUM_OFFSET\:gsp.cpp}
{\xe \v gsp.cpp\:ZERROBOTICS_TESTNUM_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define {\b ZERROBOTICS_TESTNUM_OFFSET}\~ (100)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file gsp.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v test_class\:gsp.cpp}
{\xe \v gsp.cpp\:test_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _test_class}  {\b test_class}}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _test_class\:gsp.cpp}
{\xe \v gsp.cpp\:_test_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _test_class}}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumerator: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v invalid_test\:gsp.cpp}
{\xe \v gsp.cpp\:invalid_test}
{\b {\i invalid_test{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
}}  \par
{\xe \v checkout_tests\:gsp.cpp}
{\xe \v gsp.cpp\:checkout_tests}
{\b {\i checkout_tests{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
}}  \par
{\xe \v zerorobotics_tests\:gsp.cpp}
{\xe \v gsp.cpp\:zerorobotics_tests}
{\b {\i zerorobotics_tests{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
}}  \par
}
\par
{
Definition at line 47 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{invalid_test, checkout_tests, zerorobotics_tests\} test_class;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_test_class\:gsp.cpp}
{\xe \v gsp.cpp\:get_test_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b test_class} {\b get_test_class} (unsigned int {\i test_num})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  if ((test_num > CHECKOUT_TESTNUM_OFFSET) && (test_num <= ZERROBOTICS_TESTNUM_OFFSET))\par
    return checkout_tests;\par
\par
  if ((test_num > ZERROBOTICS_TESTNUM_OFFSET))\par
    return zerorobotics_tests;\par
    \par
  return invalid_test;\par
\}\par
}
}
{\xe \v gspControl\:gsp.cpp}
{\xe \v gsp.cpp\:gspControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspControl} (unsigned int {\i test_number}, unsigned int {\i test_time}, unsigned int {\i maneuver_number}, unsigned int {\i maneuver_time})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  switch (testclass)\par
  \{\par
    case checkout_tests:\par
      gspControl_Checkout(testnum, test_time, maneuver_number, maneuver_time); \par
      break;\par
    case zerorobotics_tests:\par
      gameImplRef.gspControl(test_number,test_time,maneuver_number,maneuver_time);\par
      break;\par
  \}\par
\}\par
}
}
{\xe \v gspIdentitySet\:gsp.cpp}
{\xe \v gsp.cpp\:gspIdentitySet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspIdentitySet} ()}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
   // set the logical identifier (SPHERE#) for this vehicle\par
   sysIdentitySet(SPHERE_ID);\par
\}\par
}
}
{\xe \v gspInitProgram\:gsp.cpp}
{\xe \v gsp.cpp\:gspInitProgram}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspInitProgram} ()}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
   // set the unique program identifier (to be assigned by MIT)\par
   sysProgramIDSet(9998);\par
\par
   // set up communications TDMA frames\par
   commTdmaStandardInit(COMM_CHANNEL_STL, sysIdentityGet(), NUM_SPHERES);\par
   commTdmaStandardInit(COMM_CHANNEL_STS, sysIdentityGet(), NUM_SPHERES);\par
\par
   // enable communications channels\par
   commTdmaEnable(COMM_CHANNEL_STL);\par
   commTdmaEnable(COMM_CHANNEL_STS);   \par
   \par
   // allocate storage space for IMU samples\par
   padsInertialAllocateBuffers(50);\par
\par
   // inform system of highest beacon number in use\par
   padsInitializeFPGA(NUM_BEACONS);\par
\}\par
}
}
{\xe \v gspInitTask\:gsp.cpp}
{\xe \v gsp.cpp\:gspInitTask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspInitTask} ()}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
\}\par
}
}
{\xe \v gspInitTest\:gsp.cpp}
{\xe \v gsp.cpp\:gspInitTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspInitTest} (unsigned int {\i test_number})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  // make a zero-offset index\par
  unsigned int index;\par
  \par
  index = test_number-1;\par
  \par
  testclass = get_test_class(refTestNumber[index]);\par
  testnum = refTestNumber[index] % 100;\par
\par
  switch (testclass)\par
  \{\par
    case checkout_tests:\par
      gspInitTest_Checkout(testnum);\par
      break;\par
    case zerorobotics_tests:\par
      gameImplRef.gspInitTest(test_number);\par
      break;\par
    default:\par
      ctrlTestTerminate(TEST_RESULT_UNKNOWN_TEST);\par
      break;\par
  \}\par
\}\par
}
}
{\xe \v gspPadsGlobal\:gsp.cpp}
{\xe \v gsp.cpp\:gspPadsGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspPadsGlobal} (unsigned int {\i beacon}, beacon_measurement_matrix {\i measurements})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 126 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
\}\par
}
}
{\xe \v gspPadsInertial\:gsp.cpp}
{\xe \v gsp.cpp\:gspPadsInertial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspPadsInertial} (IMU_sample * {\i accel}, IMU_sample * {\i gyro}, unsigned int {\i num_samples})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 121 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
\}\par
}
}
{\xe \v gspProcessRXData\:gsp.cpp}
{\xe \v gsp.cpp\:gspProcessRXData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspProcessRXData} (default_rfm_packet {\i packet})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 157 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  //USED TO AVOID CHECKS IN MUDFLAP\par
  #ifdef ZRSIMULATION\par
    default_rfm_packet localPacket;\par
    unchecked_memcpy(localPacket,packet,37);\par
  #else\par
    #define localPacket packet\par
  #endif\par
  switch(testclass)\par
  \{\par
    case zerorobotics_tests:\par
      gameImplRef.gspProcessRXData(packet);\par
    break;\par
  \par
  \}\par
  #ifndef ZRSIMULATION\par
  #undef localPacket\par
  #endif\par
\}\par
}
}
{\xe \v gspTaskRun\:gsp.cpp}
{\xe \v gsp.cpp\:gspTaskRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b gspTaskRun} (unsigned int {\i gsp_task_trigger}, unsigned int {\i extra_data})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file gsp.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  switch (testclass)\par
  \{\par
    case checkout_tests:\par
      gspTaskRun_Checkout(gsp_task_trigger,extra_data);\par
      break;\par
  \}\par
\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gameImplRef\:gsp.cpp}
{\xe \v gsp.cpp\:gameImplRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl}& {\b gameImplRef} = {\b ZeroRoboticsGameImpl::instance}(){\f2  [static]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file gsp.cpp.}\par
}
{\xe \v refTestNumber\:gsp.cpp}
{\xe \v gsp.cpp\:refTestNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned int {\b refTestNumber}[] = \{101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 199\}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file gsp.cpp.}\par
}
{\xe \v testclass\:gsp.cpp}
{\xe \v gsp.cpp\:testclass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b testclass}{\f2  [static]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file gsp.cpp.}\par
}
{\xe \v testnum\:gsp.cpp}
{\xe \v gsp.cpp\:testnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int {\b testnum} = 0{\f2  [static]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file gsp.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRCamera.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZRCamera.cpp}
{\xe \v ZRCamera.cpp}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "ZRGame.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRCommRoutines.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZRCommRoutines.cpp}
{\xe \v ZRCommRoutines.cpp}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ZRGame.h"}\par
{\f2 #include "spheres_types.h"}\par
{\f2 #include "comm.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZREnergy.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZREnergy.cpp}
{\xe \v ZREnergy.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "ZRGame.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRGame.h File Reference\par \pard\plain 
{\tc\tcl2 \v ZRGame.h}
{\xe \v ZRGame.h}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains documentation of functions specific to the player side of the game. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "pads.h"}\par
{\f2 #include "Constants.h"}\par
{\f2 #include "spheres_constants.h"}\par
{\f2 #include "ZR_API.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ZeroRoboticsGame}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class of the game object that you will use. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains documentation of functions specific to the player side of the game. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this documentation to learn about using the API functions available in the challenge. General API operations for Zero Robotics are available under ZR_API.h.\par
Access members of this file by using the syntax "game.functionname(inputs);" \par
}{
Definition in file {\b ZRGame.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRGameInternal.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZRGameInternal.cpp}
{\xe \v ZRGameInternal.cpp}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "ZRGame.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
{\f2 #include "ZR_API_internal.h"}\par
{\f2 #include "ZR_API.h"}\par
{\f2 #include "Constants.h"}\par
{\f2 #include "commands.h"}\par
{\f2 #include "system.h"}\par
{\f2 #include "math_matrix.h"}\par
{\f2 #include "gsp.h"}\par
{\f2 #include "control.h"}\par
{\f2 #include "find_state_error.h"}\par
{\f2 #include "housekeeping_internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGameImpl} * {\b getGameImpl} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swingTwistDecomposition} (float q[4], float q_sw[4], float q_tw[4], float tw_axis[3])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b quatToPositive} (float quat[4])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
state_vector {\b initStateZR} = \{0.4,-0.6,0, 0,0,0, 0.7071,-0.7071,0,0, 0,0,0\}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file is used to define the C++ implementation of both the public and the private game API functions. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getGameImpl\:ZRGameInternal.cpp}
{\xe \v ZRGameInternal.cpp\:getGameImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl}* {\b getGameImpl} ()}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return &ZeroRoboticsGameImpl::instance();\par
\}\par
}
}
{\xe \v quatToPositive\:ZRGameInternal.cpp}
{\xe \v ZRGameInternal.cpp\:quatToPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b quatToPositive} (float {\i quat}[4])}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 223 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                    \{\par
    if (quat[3] < 0) \{\par
      for (int i = 0; i < 4; i++) \{\par
        quat[4] *= -1;\par
      \}\par
    \}\par
\}\par
}
}
{\xe \v swingTwistDecomposition\:ZRGameInternal.cpp}
{\xe \v ZRGameInternal.cpp\:swingTwistDecomposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b swingTwistDecomposition} (float {\i q}[4], float {\i q_sw}[4], float {\i q_tw}[4], float {\i tw_axis}[3])}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                    \{\par
  \par
  // p = dot(q[0:2], tw_axis) * tw_axis\par
  // q_tw = [p[0], p[1], p[2], q[3]]\par
  float c = mathVecInner(q, tw_axis, 3);\par
  for (int i = 0; i < 3; i++) \{\par
    q_tw[i]= tw_axis[i] * c;    \par
  \}\par
  q_tw[3] = q[3];\par
  mathVecNormalize(q_tw, 4);\par
  \par
  // invert twist quaternion\par
  float q_tw_inv[4];\par
  memcpy(q_tw_inv, q_tw, 4*sizeof(float));  \par
  for (int i = 0; i < 3; i++) \{\par
    q_tw_inv[i] *= -1.0f;\par
  \}\par
    \par
  quatMult(q_sw, q_tw_inv, q);\par
\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v initStateZR\:ZRGameInternal.cpp}
{\xe \v ZRGameInternal.cpp\:initStateZR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
state_vector {\b initStateZR} = \{0.4,-0.6,0, 0,0,0, 0.7071,-0.7071,0,0, 0,0,0\}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file is used to define the C++ implementation of both the public and the private game API functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public functions will be prefixed with {\b ZeroRoboticsGame}:: while private implementation functions will be prefixed with {\b ZeroRoboticsGameImpl}:: Use these vectors to choose the satellites state when the user is given control. \par
}{
Definition at line 32 of file ZRGameInternal.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRGameInternal.h File Reference\par \pard\plain 
{\tc\tcl2 \v ZRGameInternal.h}
{\xe \v ZRGameInternal.h}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
{\f2 #include "ZeroRoboticsGameBaseImpl.hpp"}\par
{\f2 #include "comm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ZeroRoboticsGameImpl}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class defines the hidden game implementation. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::PlayerInfo}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(Required) Runs initialization fo the ZR game at the start of a test. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::OtherInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::Light}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::Picture}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::Camera}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ZeroRoboticsGameImpl::ChallengeInfo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ZeroRoboticsGameImpl} * {\b getGameImpl} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b overrideTarget2D} (float target[13])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swingTwistDecomposition} (float q[4], float q_sw[4], float q_tw[4], float sw_vec[3])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b quatToPositive} (float q[4])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v getGameImpl\:ZRGameInternal.h}
{\xe \v ZRGameInternal.h\:getGameImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ZeroRoboticsGameImpl}* {\b getGameImpl} ()}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  return &ZeroRoboticsGameImpl::instance();\par
\}\par
}
}
{\xe \v overrideTarget2D\:ZRGameInternal.h}
{\xe \v ZRGameInternal.h\:overrideTarget2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b overrideTarget2D} (float {\i target}[13])}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v quatToPositive\:ZRGameInternal.h}
{\xe \v ZRGameInternal.h\:quatToPositive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b quatToPositive} (float {\i q}[4])}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 223 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                    \{\par
    if (quat[3] < 0) \{\par
      for (int i = 0; i < 4; i++) \{\par
        quat[4] *= -1;\par
      \}\par
    \}\par
\}\par
}
}
{\xe \v swingTwistDecomposition\:ZRGameInternal.h}
{\xe \v ZRGameInternal.h\:swingTwistDecomposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b swingTwistDecomposition} (float {\i q}[4], float {\i q_sw}[4], float {\i q_tw}[4], float {\i sw_vec}[3])}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file ZRGameInternal.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid                                    \{\par
  \par
  // p = dot(q[0:2], tw_axis) * tw_axis\par
  // q_tw = [p[0], p[1], p[2], q[3]]\par
  float c = mathVecInner(q, tw_axis, 3);\par
  for (int i = 0; i < 3; i++) \{\par
    q_tw[i]= tw_axis[i] * c;    \par
  \}\par
  q_tw[3] = q[3];\par
  mathVecNormalize(q_tw, 4);\par
  \par
  // invert twist quaternion\par
  float q_tw_inv[4];\par
  memcpy(q_tw_inv, q_tw, 4*sizeof(float));  \par
  for (int i = 0; i < 3; i++) \{\par
    q_tw_inv[i] *= -1.0f;\par
  \}\par
    \par
  quatMult(q_sw, q_tw_inv, q);\par
\}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRItems.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZRItems.cpp}
{\xe \v ZRItems.cpp}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include "ZRGame.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdremboss\brdrw15\brsp20 \adjustright \par}
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ZRLight.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v ZRLight.cpp}
{\xe \v ZRLight.cpp}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <math.h>}\par
{\f2 #include <cmath>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include "ZRGame.h"}\par
{\f2 #include "ZRGameInternal.h"}\par
}

\pard\plain \sect\sbknone
{\pard\widctlpar\brdrb\brdrs\brdrw75\brsp20 \adjustright \par}
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}